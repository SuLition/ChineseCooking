<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏≠ÂçéÊñôÁêÜ‰º†Â•á - Chinese Cuisine Legend</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        :root {
            --primary-red: #c41e3a;
            --gold: #ffd700;
            --dark-wood: #4a3728;
            --light-wood: #8b7355;
            --bg-warm: #2d1f1a;
            --text-light: #f5e6d3;
            --success-green: #4ade80;
            --warning-orange: #fb923c;
            --perfect-purple: #a855f7;
        }
        
        body {
            font-family: 'ZCOOL KuaiLe', cursive;
            background: var(--bg-warm);
            min-height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(180deg, #1a0f0a 0%, #2d1f1a 50%, #3d2a1f 100%);
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.5);
        }
        
        /* È°∂ÈÉ®‰ø°ÊÅØÊ†è */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 74px;
            background: linear-gradient(180deg, var(--dark-wood) 0%, #3a2a1f 100%);
            border-bottom: 4px solid var(--light-wood);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
        }
        
        .top-left, .top-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .stat-box {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--gold);
            border-radius: 6px;
            padding: 8px 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            color: var(--text-light);
        }
        
        .stat-box.goal-box {
            border-color: var(--warning-orange);
            min-width: 180px;
        }
        
        .stat-icon {
            font-size: 22px;
        }
        
        .stat-value {
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            color: var(--gold);
        }
        
        .goal-info {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .goal-text {
            font-size: 12px;
            color: var(--text-light);
        }
        
        .goal-bar-mini {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .goal-fill-mini {
            height: 100%;
            background: linear-gradient(90deg, var(--warning-orange), var(--gold));
            transition: width 0.3s;
        }
        
        #game-title {
            font-size: 28px;
            color: var(--gold);
            text-shadow: 
                3px 3px 0 var(--primary-red),
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000;
            letter-spacing: 4px;
        }
        
        /* Êìç‰ΩúÊåâÈíÆ */
        .action-btn-small {
            background: linear-gradient(180deg, var(--primary-red) 0%, #8b1225 100%);
            border: 2px solid var(--gold);
            color: var(--text-light);
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 16px;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .action-btn-small:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        /* ‰∏ªÊ∏∏ÊàèÂå∫Âüü */
        #main-area {
            position: absolute;
            top: 78px;
            left: 0;
            right: 400px;
            bottom: 200px;
            display: flex;
            flex-direction: column;
        }
        
        /* È°æÂÆ¢ÈòüÂàóÂå∫ */
        #customer-area {
            height: 220px;
            background: linear-gradient(180deg, #1a0f0a 0%, transparent 100%);
            border-bottom: 3px solid var(--light-wood);
            display: flex;
            align-items: center;
            padding: 15px 25px;
            gap: 20px;
            overflow-x: auto;
        }
        
        .customer {
            width: 130px;
            height: 180px;
            background: rgba(0,0,0,0.3);
            border: 3px solid var(--light-wood);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            flex-shrink: 0;
            transition: all 0.3s;
            position: relative;
            cursor: pointer;
        }
        
        .customer:hover {
            transform: translateY(-5px);
            border-color: var(--gold);
        }
        
        .customer.selected {
            border-color: var(--success-green);
            box-shadow: 0 0 20px rgba(74,222,128,0.5);
        }
        
        .customer.special {
            border-color: var(--perfect-purple);
            animation: special-glow 1s ease-in-out infinite;
        }
        
        @keyframes special-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(168,85,247,0.5); }
            50% { box-shadow: 0 0 25px rgba(168,85,247,0.8); }
        }
        
        .customer-avatar {
            width: 56px;
            height: 56px;
            background: var(--primary-red);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin-bottom: 5px;
            position: relative;
        }
        
        .customer-mood {
            position: absolute;
            top: -5px;
            right: -10px;
            font-size: 20px;
            animation: mood-bounce 0.5s ease-in-out infinite;
        }
        
        @keyframes mood-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        
        .customer-order {
            font-size: 13px;
            color: var(--text-light);
            text-align: center;
            margin-bottom: 5px;
        }
        
        .customer-order-icon {
            font-size: 32px;
            margin-bottom: 4px;
        }
        
        .patience-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .patience-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-red), var(--gold));
            transition: width 0.1s linear;
        }
        
        .patience-fill.low {
            background: var(--primary-red);
            animation: pulse-red 0.5s ease-in-out infinite;
        }
        
        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .customer-tip {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--gold);
            color: #000;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Press Start 2P', monospace;
        }
        
        /* ÁÉπÈ•™Âè∞Âå∫Âüü */
        #cooking-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            padding: 30px;
            background: radial-gradient(ellipse at center, rgba(255,200,100,0.1) 0%, transparent 70%);
        }
        
        .cooking-station {
            width: 220px;
            height: 220px;
            background: linear-gradient(180deg, #5a4a3a 0%, #3a2a1f 100%);
            border: 4px solid var(--light-wood);
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        
        .cooking-station:hover {
            transform: scale(1.05);
            border-color: var(--gold);
        }
        
        .cooking-station.cooking {
            border-color: var(--warning-orange);
            animation: cooking-glow 1s ease-in-out infinite;
        }
        
        @keyframes cooking-glow {
            0%, 100% { box-shadow: 0 8px 20px rgba(251,146,60,0.3); }
            50% { box-shadow: 0 8px 30px rgba(251,146,60,0.6); }
        }
        
        .cooking-station.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .station-icon {
            font-size: 64px;
            margin-bottom: 10px;
        }
        
        .station-name {
            font-size: 16px;
            color: var(--text-light);
        }
        
        .station-progress {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 10px;
            background: #222;
            border-radius: 5px;
            overflow: hidden;
            display: none;
        }
        
        .station-progress.active {
            display: block;
        }
        
        .station-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-green), #22c55e);
            transition: width 0.1s linear;
        }
        
        .station-dish {
            position: absolute;
            top: 20px;
            font-size: 48px;
            animation: cooking-bounce 0.5s ease-in-out infinite;
        }
        
        @keyframes cooking-bounce {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-5px) rotate(5deg); }
        }
        
        /* È£üÊùêÈÄâÊã©Âå∫ */
        #ingredient-area {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 400px;
            height: 200px;
            background: linear-gradient(180deg, #3a2a1f 0%, var(--dark-wood) 100%);
            border-top: 3px solid var(--light-wood);
            padding: 15px 20px;
        }
        
        #ingredient-title {
            font-size: 18px;
            color: var(--gold);
            margin-bottom: 10px;
        }
        
        #ingredient-grid {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 10px;
        }
        
        .ingredient {
            width: 80px;
            height: 95px;
            background: rgba(0,0,0,0.4);
            border: 3px solid var(--light-wood);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .ingredient:hover {
            transform: translateY(-5px);
            border-color: var(--gold);
        }
        
        .ingredient.selected {
            border-color: var(--success-green);
            background: rgba(74,222,128,0.2);
        }
        
        .ingredient-icon {
            font-size: 36px;
            margin-bottom: 4px;
        }
        
        .ingredient-name {
            font-size: 11px;
            color: var(--text-light);
            text-align: center;
        }
        
        /* Âè≥‰æßÁÉπÈ•™Èù¢Êùø */
        #cooking-panel {
            position: absolute;
            top: 78px;
            right: 0;
            width: 400px;
            bottom: 0;
            background: linear-gradient(180deg, #2a1a15 0%, #1a0f0a 100%);
            border-left: 3px solid var(--light-wood);
            display: flex;
            flex-direction: column;
        }
        
        #cooking-panel-header {
            padding: 12px 15px;
            border-bottom: 2px solid var(--light-wood);
            text-align: center;
        }
        
        #cooking-panel-title {
            font-size: 20px;
            color: var(--gold);
            margin-bottom: 8px;
        }
        
        #cooking-step-info {
            font-size: 14px;
            color: var(--text-light);
        }
        
        #cooking-canvas-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
        }
        
        #cooking-canvas {
            background: #1a1a1a;
            border: 3px solid var(--light-wood);
            border-radius: 10px;
            cursor: crosshair;
        }
        
        #cooking-controls {
            padding: 15px;
            border-top: 2px solid var(--light-wood);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .cooking-progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .cooking-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-green), #22c55e);
            transition: width 0.1s;
        }
        
        .cooking-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        
        .heat-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .heat-label {
            font-size: 14px;
            color: var(--text-light);
            min-width: 60px;
        }
        
        .heat-slider {
            flex: 1;
            height: 30px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #3b82f6, #22c55e, #eab308, #ef4444);
            border-radius: 15px;
            outline: none;
        }
        
        .heat-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 30px;
            background: white;
            border: 3px solid #333;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .heat-display {
            font-size: 14px;
            color: var(--gold);
            min-width: 50px;
            text-align: right;
        }
        
        #cooking-action-btn {
            background: linear-gradient(180deg, var(--primary-red) 0%, #8b1225 100%);
            border: 3px solid var(--gold);
            color: var(--text-light);
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 18px;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #cooking-action-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(255,215,0,0.4);
        }
        
        #cooking-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* ÁÉπÈ•™ÊèêÁ§∫ */
        .cooking-hint {
            background: rgba(0,0,0,0.7);
            border: 2px solid var(--warning-orange);
            border-radius: 8px;
            padding: 10px;
            font-size: 13px;
            color: var(--text-light);
            text-align: center;
        }
        
        /* ËØÑÂàÜÊòæÁ§∫ */
        .score-display {
            display: flex;
            justify-content: center;
            gap: 5px;
            font-size: 24px;
        }
        
        /* ÂæÖÂ§ÑÁêÜÈ£üÊùêÊòæÁ§∫ */
        #pending-ingredients {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            flex-wrap: wrap;
        }
        
        .pending-item {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--light-wood);
            border-radius: 6px;
            padding: 5px 10px;
            font-size: 20px;
            opacity: 0.5;
            transition: all 0.3s;
        }
        
        .pending-item.active {
            border-color: var(--success-green);
            opacity: 1;
            box-shadow: 0 0 10px rgba(74,222,128,0.5);
        }
        
        .pending-item.done {
            border-color: var(--gold);
            opacity: 0.8;
        }
        
        /* ÁâπÊÆä‰∫ã‰ª∂Èù¢Êùø */
        #special-event {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #3a2a1f 0%, #1a0f0a 100%);
            border: 6px solid var(--perfect-purple);
            border-radius: 16px;
            padding: 30px;
            z-index: 500;
            display: none;
            text-align: center;
            min-width: 400px;
        }
        
        #special-event.active {
            display: block;
            animation: event-popup 0.5s ease-out;
        }
        
        @keyframes event-popup {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        #event-icon {
            font-size: 80px;
            margin-bottom: 15px;
            animation: event-bounce 1s ease-in-out infinite;
        }
        
        @keyframes event-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        #event-title {
            font-size: 28px;
            color: var(--gold);
            margin-bottom: 10px;
        }
        
        #event-desc {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 20px;
        }
        
        .event-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .event-btn {
            padding: 12px 25px;
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 16px;
            border: 3px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .event-btn:hover {
            transform: scale(1.05);
        }
        
        .event-btn.positive {
            background: var(--success-green);
            border-color: #22c55e;
            color: #000;
        }
        
        .event-btn.negative {
            background: var(--primary-red);
            border-color: #ff6b6b;
            color: var(--text-light);
        }
        
        .event-btn.neutral {
            background: var(--gold);
            border-color: #ffa500;
            color: #000;
        }
        
        /* ÂçáÁ∫ßÈù¢Êùø */
        #upgrade-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #3a2a1f 0%, #1a0f0a 100%);
            border: 6px solid var(--gold);
            border-radius: 16px;
            padding: 30px;
            z-index: 300;
            display: none;
            min-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #upgrade-panel.active {
            display: block;
            animation: popup 0.3s ease-out;
        }
        
        .upgrade-title {
            font-size: 28px;
            color: var(--gold);
            text-align: center;
            margin-bottom: 20px;
        }
        
        .upgrade-category {
            margin-bottom: 20px;
        }
        
        .upgrade-category-title {
            font-size: 18px;
            color: var(--warning-orange);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--light-wood);
        }
        
        .upgrade-item {
            background: rgba(0,0,0,0.4);
            border: 3px solid var(--light-wood);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .upgrade-icon {
            font-size: 36px;
        }
        
        .upgrade-info {
            flex: 1;
        }
        
        .upgrade-name {
            font-size: 16px;
            color: var(--text-light);
        }
        
        .upgrade-desc {
            font-size: 11px;
            color: #888;
        }
        
        .upgrade-level {
            font-size: 11px;
            color: var(--success-green);
        }
        
        .upgrade-btn {
            background: linear-gradient(180deg, var(--gold) 0%, #b8860b 100%);
            border: none;
            color: #000;
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 13px;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upgrade-btn:hover {
            transform: scale(1.05);
        }
        
        .upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--primary-red);
            border: 2px solid var(--gold);
            color: var(--text-light);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* ÈÅÆÁΩ©Â±Ç */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 250;
            display: none;
        }
        
        #overlay.active {
            display: block;
        }
        
        /* ÊèêÁ§∫Ê°Ü */
        .toast {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 600;
            animation: toast-in 0.3s ease-out, toast-out 0.3s ease-in 1.7s forwards;
        }
        
        .toast.success {
            background: var(--success-green);
            color: #000;
            border: 3px solid #22c55e;
        }
        
        .toast.error {
            background: var(--primary-red);
            color: var(--text-light);
        }
        
        .toast.money {
            background: var(--gold);
            color: #000;
        }
        
        .toast.perfect {
            background: var(--perfect-purple);
            color: var(--text-light);
            font-size: 24px;
        }
        
        @keyframes toast-in {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        @keyframes toast-out {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        /* ËøûÂáªÊòæÁ§∫ */
        #combo-display {
            position: fixed;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: var(--gold);
            text-shadow: 3px 3px 0 var(--primary-red);
            z-index: 400;
            display: none;
        }
        
        #combo-display.active {
            display: block;
            animation: combo-pop 0.5s ease-out;
        }
        
        @keyframes combo-pop {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.3); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        
        /* ÂºÄÂßãÁïåÈù¢ */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #3d2a1f 0%, #1a0f0a 100%);
            z-index: 700;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #start-screen.hidden {
            display: none;
        }
        
        #game-logo {
            font-size: 56px;
            color: var(--gold);
            text-shadow: 
                4px 4px 0 var(--primary-red),
                -2px -2px 0 #000;
            margin-bottom: 20px;
            animation: logo-pulse 2s ease-in-out infinite;
        }
        
        @keyframes logo-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #game-subtitle {
            font-size: 24px;
            color: var(--text-light);
            margin-bottom: 50px;
            opacity: 0.8;
        }
        
        #start-btn {
            background: linear-gradient(180deg, var(--primary-red) 0%, #8b1225 100%);
            border: 4px solid var(--gold);
            color: var(--text-light);
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 28px;
            padding: 15px 60px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            animation: btn-glow 1.5s ease-in-out infinite;
        }
        
        @keyframes btn-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255,215,0,0.3); }
            50% { box-shadow: 0 0 40px rgba(255,215,0,0.6); }
        }
        
        #start-btn:hover {
            transform: scale(1.1);
        }
        
        .start-decoration {
            font-size: 80px;
            margin-bottom: 30px;
        }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            color: var(--text-light);
            opacity: 0.6;
            font-size: 14px;
        }
        
        /* ÊàêÂ∞±ÊèêÁ§∫ */
        .achievement {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(180deg, #4a3728 0%, #2d1f1a 100%);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 15px 20px;
            z-index: 600;
            display: flex;
            align-items: center;
            gap: 15px;
            animation: achievement-in 0.5s ease-out, achievement-out 0.5s ease-in 2.5s forwards;
        }
        
        .achievement-icon {
            font-size: 40px;
        }
        
        .achievement-text {
            color: var(--text-light);
        }
        
        .achievement-title {
            font-size: 16px;
            color: var(--gold);
        }
        
        @keyframes achievement-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes achievement-out {
            from { opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        /* ÊµÆÂä®ÈáëÂ∏ÅÊïàÊûú */
        .floating-coin {
            position: fixed;
            font-size: 24px;
            pointer-events: none;
            z-index: 500;
            animation: float-up 1s ease-out forwards;
        }
        
        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-80px); }
        }
        
        /* ÊªöÂä®Êù° */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--dark-wood);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--light-wood);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--gold);
        }
        
        /* Èü≥ÊïàÈù¢ÊùøÊ†∑Âºè */
        .sound-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 280px;
            background: linear-gradient(180deg, #3a2a1f 0%, #2a1a15 100%);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 15px;
            z-index: 1000;
            display: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
        .sound-panel.active { display: block; animation: fadeIn 0.2s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .sound-panel-title {
            font-size: 18px;
            color: var(--gold);
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-wood);
        }
        .sound-control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            color: var(--text-light);
            font-size: 14px;
        }
        .sound-toggle-btn {
            width: 50px;
            padding: 6px 12px;
            border: 2px solid var(--light-wood);
            background: #333;
            color: #888;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }
        .sound-toggle-btn.active {
            background: var(--success-green);
            color: #fff;
            border-color: var(--success-green);
        }
        .sound-control-row input[type="range"] {
            width: 120px;
            height: 8px;
            -webkit-appearance: none;
            background: #444;
            border-radius: 4px;
            outline: none;
        }
        .sound-control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--gold);
            border-radius: 50%;
            cursor: pointer;
        }
        .sound-close-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: linear-gradient(180deg, var(--primary-red) 0%, #8b1225 100%);
            border: 2px solid var(--gold);
            color: var(--text-light);
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
        }
        .sound-close-btn:hover { transform: scale(1.02); box-shadow: 0 0 10px rgba(255,215,0,0.4); }
    </style>
</head>
<body>
    <!-- ÂºÄÂßãÁïåÈù¢ -->
    <div id="start-screen">
        <div class="start-decoration">ü•¢üçúü•ü</div>
        <div id="game-logo">‰∏≠ÂçéÊñôÁêÜ‰º†Â•á</div>
        <div id="game-subtitle">Chinese Cuisine Legend</div>
        <button id="start-btn" onclick="startGame()">ÂºÄÂßãËê•‰∏ö</button>
        <div id="instructions">ÈÄâÊã©È°æÂÆ¢ ‚Üí ÈÄâÊã©È£üÊùê ‚Üí ÁÇπÂáªÁÉπÈ•™Âè∞ ‚Üí ÊúçÂä°È°æÂÆ¢ ‚Üí ÂçáÁ∫ßÂé®Êàø</div>
    </div>
    
    <!-- Ê∏∏Êàè‰∏ªÂÆπÂô® -->
    <div id="game-container">
        <!-- È°∂ÈÉ®‰ø°ÊÅØÊ†è -->
        <div id="top-bar">
            <div class="top-left">
                <div class="stat-box">
                    <div class="stat-icon">üí∞</div>
                    <div>
                        <div style="font-size: 10px; color: #888;">ÈáëÂ∏Å</div>
                        <div class="stat-value" id="money-display">0</div>
                    </div>
                </div>
                <div class="stat-box">
                    <div class="stat-icon">‚≠ê</div>
                    <div>
                        <div style="font-size: 10px; color: #888;">Â£∞Êúõ</div>
                        <div class="stat-value" id="reputation-display">0</div>
                    </div>
                </div>
                <div class="stat-box">
                    <div class="stat-icon">üìä</div>
                    <div>
                        <div style="font-size: 10px; color: #888;">Á≠âÁ∫ß</div>
                        <div class="stat-value" id="level-display">1</div>
                    </div>
                </div>
            </div>
            
            <div id="game-title">üèÆ ‰∏≠ÂçéÊñôÁêÜ‰º†Â•á üèÆ</div>
            
            <div class="top-right">
                <div class="stat-box" style="min-width: 120px;">
                    <div class="stat-icon" id="time-period-icon">üåÖ</div>
                    <div>
                        <div style="font-size: 10px; color: #888;" id="time-period-name">Êó©È§êÊó∂ÊÆµ</div>
                        <div class="stat-value" id="game-time-display">07:00</div>
                    </div>
                </div>
                <div class="stat-box goal-box">
                    <div class="stat-icon">üéØ</div>
                    <div class="goal-info">
                        <div class="goal-text">‰ªäÊó•: <span id="goal-current">0</span>/<span id="goal-target">10</span> üí∞<span id="daily-reward-val">200</span></div>
                        <div class="goal-bar-mini">
                            <div class="goal-fill-mini" id="goal-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <button class="action-btn-small" onclick="openUpgradePanel()">üîß ÂçáÁ∫ß</button>
                <button class="action-btn-small" onclick="toggleAutoServe()">ü§ñ Ëá™Âä®</button>
                <button class="action-btn-small" id="sound-btn" onclick="openSoundPanel()">üîä Èü≥Êïà</button>
            </div>
        </div>
        
        <!-- Èü≥ÊïàËÆæÁΩÆÈù¢Êùø -->
        <div id="sound-panel" class="sound-panel">
            <div class="sound-panel-title">üîä Èü≥ÊïàËÆæÁΩÆ</div>
            <div class="sound-control-row">
                <span>üéµ ËÉåÊôØÈü≥‰πê</span>
                <button id="bgm-toggle" class="sound-toggle-btn active" onclick="toggleBGM()">ÂºÄ</button>
            </div>
            <div class="sound-control-row">
                <span>üîà Èü≥Êïà</span>
                <button id="sfx-toggle" class="sound-toggle-btn active" onclick="toggleSFX()">ÂºÄ</button>
            </div>
            <div class="sound-control-row">
                <span>üéöÔ∏è Èü≥‰πêÈü≥Èáè</span>
                <input type="range" id="music-volume" min="0" max="100" value="30" oninput="setMusicVolume(this.value)">
            </div>
            <div class="sound-control-row">
                <span>üéöÔ∏è Èü≥ÊïàÈü≥Èáè</span>
                <input type="range" id="sfx-volume" min="0" max="100" value="50" oninput="setSFXVolume(this.value)">
            </div>
            <button class="sound-close-btn" onclick="closeSoundPanel()">ÂÖ≥Èó≠</button>
        </div>
        
        <!-- ‰∏ªÂå∫Âüü -->
        <div id="main-area">
            <!-- È°æÂÆ¢ÈòüÂàó -->
            <div id="customer-area"></div>
            
            <!-- ÁÉπÈ•™Âè∞ -->
            <div id="cooking-area"></div>
        </div>
        
        <!-- È£üÊùêÈÄâÊã©Âå∫ -->
        <div id="ingredient-area">
            <div id="ingredient-title">ü•¨ È£üÊùêÂ∫ì <span id="selected-count" style="font-size: 14px; color: var(--text-light);">(Â∑≤ÈÄâ: 0/3)</span></div>
            <div id="ingredient-grid"></div>
        </div>
        
        <!-- ÁÉπÈ•™Èù¢Êùø -->
        <div id="cooking-panel">
            <div id="cooking-panel-header">
                <div id="cooking-panel-title">üç≥ ÁÉπÈ•™Âè∞</div>
                <div id="cooking-step-info">ÈÄâÊã©È°æÂÆ¢ÂºÄÂßãÁÉπÈ•™</div>
                <div id="pending-ingredients"></div>
            </div>
            <div id="cooking-canvas-container">
                <canvas id="cooking-canvas" width="360" height="360"></canvas>
            </div>
            <div id="cooking-controls">
                <div class="cooking-hint" id="cooking-hint">ÈÄâÊã©‰∏Ä‰ΩçÈ°æÂÆ¢ÔºåÁÑ∂ÂêéÁÇπÂáªÁÉπÈ•™Âè∞ÂºÄÂßãÂà∂‰ΩúÁæéÈ£üÔºÅ</div>
                <div class="cooking-progress-bar" id="cooking-progress-container" style="display: none;">
                    <div class="cooking-progress-fill" id="cooking-progress-fill"></div>
                    <div class="cooking-progress-text" id="cooking-progress-text">0%</div>
                </div>
                <div class="heat-control" id="heat-control" style="display: none;">
                    <span class="heat-label">üî• ÁÅ´Âäõ</span>
                    <input type="range" class="heat-slider" id="heat-slider" min="0" max="100" value="50">
                    <span class="heat-display" id="heat-display">‰∏≠ÁÅ´</span>
                </div>
                <button id="cooking-action-btn" style="display: none;">ÂºÄÂßãÁÉπÈ•™</button>
            </div>
        </div>
    </div>
    
    <!-- ÁâπÊÆä‰∫ã‰ª∂Èù¢Êùø -->
    <div id="special-event">
        <div id="event-icon"></div>
        <div id="event-title"></div>
        <div id="event-desc"></div>
        <div class="event-buttons" id="event-buttons"></div>
    </div>
    
    <!-- ÂçáÁ∫ßÈù¢Êùø -->
    <div id="overlay" onclick="closeAllPanels()"></div>
    <div id="upgrade-panel">
        <button class="close-btn" onclick="closeUpgradePanel()">‚úï</button>
        <div class="upgrade-title">üîß ÂçáÁ∫ßÂé®Êàø</div>
        <div id="upgrade-content"></div>
    </div>
    
    <!-- ËøûÂáªÊòæÁ§∫ -->
    <div id="combo-display"></div>
    
    <script>
        // ============ Èü≥ÊïàÁ≥ªÁªü ============
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.musicGain = null;
                this.sfxGain = null;
                this.isMuted = false;
                this.musicEnabled = true;
                this.sfxEnabled = true;
                this.musicVolume = 0.3;
                this.sfxVolume = 0.5;
                this.bgmInterval = null;
                this.activeSounds = new Map();
                this.initialized = false;
            }
            
            async init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = 0.8;
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.connect(this.masterGain);
                    this.musicGain.gain.value = this.musicVolume;
                    this.sfxGain = this.audioContext.createGain();
                    this.sfxGain.connect(this.masterGain);
                    this.sfxGain.gain.value = this.sfxVolume;
                    this.initialized = true;
                    console.log('üîä Èü≥ÊïàÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàê');
                } catch(e) { console.error('Èü≥ÊïàÂàùÂßãÂåñÂ§±Ë¥•:', e); }
            }
            
            resume() {
                if (this.audioContext?.state === 'suspended') this.audioContext.resume();
            }
            
            createOscillator(type, frequency, duration, gain = 0.3) {
                if (!this.initialized || !this.sfxEnabled) return;
                const osc = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                osc.type = type;
                osc.frequency.value = frequency;
                gainNode.gain.setValueAtTime(gain, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                osc.connect(gainNode);
                gainNode.connect(this.sfxGain);
                osc.start();
                osc.stop(this.audioContext.currentTime + duration);
            }
            
            createNoise(duration, gain = 0.1) {
                if (!this.initialized || !this.sfxEnabled) return;
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(gain, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3000;
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.sfxGain);
                noise.start();
                noise.stop(this.audioContext.currentTime + duration);
            }
            
            // UIÈü≥Êïà
            playClick() {
                this.createOscillator('sine', 800, 0.05, 0.15);
                setTimeout(() => this.createOscillator('sine', 1000, 0.03, 0.1), 20);
            }
            playSelect() {
                this.createOscillator('sine', 600, 0.08, 0.2);
                setTimeout(() => this.createOscillator('sine', 800, 0.08, 0.15), 50);
            }
            playHover() { this.createOscillator('sine', 400, 0.03, 0.05); }
            
            // È°æÂÆ¢Èü≥Êïà
            playCustomerArrive() {
                [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => this.createOscillator('sine', f, 0.15, 0.2), i * 100));
            }
            playCustomerHappy() {
                [523, 659, 784, 1047, 1319].forEach((f, i) => setTimeout(() => this.createOscillator('sine', f, 0.12, 0.15), i * 60));
            }
            playCustomerAngry() {
                this.createOscillator('sawtooth', 200, 0.3, 0.15);
                setTimeout(() => this.createOscillator('sawtooth', 150, 0.4, 0.12), 150);
            }
            playCustomerWarning() {
                this.createOscillator('square', 440, 0.1, 0.1);
                setTimeout(() => this.createOscillator('square', 440, 0.1, 0.1), 150);
            }
            
            // ÁÉπÈ•™Èü≥Êïà
            playChop() {
                this.createNoise(0.08, 0.25);
                this.createOscillator('triangle', 200 + Math.random() * 100, 0.05, 0.15);
            }
            playSizzle() {
                if (!this.initialized || !this.sfxEnabled) return;
                const duration = 0.3;
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / this.audioContext.sampleRate;
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 5) * 0.5;
                }
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 5000 + Math.random() * 3000;
                filter.Q.value = 2;
                const gain = this.audioContext.createGain();
                gain.gain.value = 0.15;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.sfxGain);
                noise.start();
                noise.stop(this.audioContext.currentTime + duration);
            }
            startSizzleLoop() {
                if (this.activeSounds.has('sizzle')) return;
                this.activeSounds.set('sizzle', setInterval(() => this.sfxEnabled && this.playSizzle(), 200));
            }
            stopSizzleLoop() {
                if (this.activeSounds.has('sizzle')) {
                    clearInterval(this.activeSounds.get('sizzle'));
                    this.activeSounds.delete('sizzle');
                }
            }
            playStirFry() {
                this.createNoise(0.15, 0.2);
                this.createOscillator('sine', 150 + Math.random() * 50, 0.1, 0.1);
            }
            playBoil() {
                for (let i = 0; i < 3; i++) setTimeout(() => this.createOscillator('sine', 100 + Math.random() * 100, 0.08, 0.08), i * 30);
            }
            startBoilLoop() {
                if (this.activeSounds.has('boil')) return;
                this.activeSounds.set('boil', setInterval(() => this.sfxEnabled && this.playBoil(), 300));
            }
            stopBoilLoop() {
                if (this.activeSounds.has('boil')) {
                    clearInterval(this.activeSounds.get('boil'));
                    this.activeSounds.delete('boil');
                }
            }
            playSteam() {
                if (!this.initialized || !this.sfxEnabled) return;
                const duration = 0.4;
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 2000;
                const gain = this.audioContext.createGain();
                gain.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.sfxGain);
                noise.start();
                noise.stop(this.audioContext.currentTime + duration);
            }
            startSteamLoop() {
                if (this.activeSounds.has('steam')) return;
                this.activeSounds.set('steam', setInterval(() => this.sfxEnabled && this.playSteam(), 500));
            }
            stopSteamLoop() {
                if (this.activeSounds.has('steam')) {
                    clearInterval(this.activeSounds.get('steam'));
                    this.activeSounds.delete('steam');
                }
            }
            playGrill() {
                this.createNoise(0.2, 0.15);
                this.createOscillator('sawtooth', 80, 0.1, 0.05);
            }
            startGrillLoop() {
                if (this.activeSounds.has('grill')) return;
                this.activeSounds.set('grill', setInterval(() => this.sfxEnabled && this.playGrill(), 400));
            }
            stopGrillLoop() {
                if (this.activeSounds.has('grill')) {
                    clearInterval(this.activeSounds.get('grill'));
                    this.activeSounds.delete('grill');
                }
            }
            playFlip() {
                this.createNoise(0.1, 0.2);
                this.createOscillator('sine', 300, 0.08, 0.1);
                setTimeout(() => this.createOscillator('sine', 400, 0.08, 0.1), 50);
            }
            playKnead() {
                this.createNoise(0.15, 0.12);
                this.createOscillator('sine', 100, 0.1, 0.08);
            }
            playMix() {
                this.createOscillator('sine', 200 + Math.random() * 50, 0.08, 0.08);
                this.createNoise(0.05, 0.05);
            }
            playPlate() {
                this.createOscillator('sine', 800, 0.1, 0.15);
                this.createOscillator('triangle', 1200, 0.08, 0.1);
            }
            playSeasoning() {
                for (let i = 0; i < 5; i++) setTimeout(() => this.createOscillator('sine', 2000 + Math.random() * 1000, 0.02, 0.08), i * 20);
            }
            
            // ÊàêÂ∞±/Â•ñÂä±Èü≥Êïà
            playSuccess() { [523, 659, 784].forEach((f, i) => setTimeout(() => this.createOscillator('sine', f, 0.2, 0.2), i * 80)); }
            playPerfect() {
                [523, 659, 784, 1047, 1319, 1568].forEach((f, i) => setTimeout(() => {
                    this.createOscillator('sine', f, 0.15, 0.2);
                    this.createOscillator('triangle', f * 2, 0.1, 0.1);
                }, i * 70));
            }
            playFail() {
                this.createOscillator('sawtooth', 200, 0.3, 0.2);
                setTimeout(() => this.createOscillator('sawtooth', 150, 0.4, 0.15), 200);
            }
            playCoin() {
                this.createOscillator('sine', 1200, 0.1, 0.15);
                setTimeout(() => this.createOscillator('sine', 1600, 0.15, 0.12), 50);
            }
            playCoins(count = 1) { for (let i = 0; i < Math.min(count, 5); i++) setTimeout(() => this.playCoin(), i * 80); }
            playLevelUp() {
                [392, 523, 659, 784, 1047].forEach((f, i) => setTimeout(() => {
                    this.createOscillator('sine', f, 0.25, 0.2);
                    this.createOscillator('triangle', f * 1.5, 0.2, 0.1);
                }, i * 120));
            }
            playCombo(combo) {
                const baseFreq = 400 + Math.min(combo, 10) * 50;
                this.createOscillator('sine', baseFreq, 0.15, 0.2);
                setTimeout(() => this.createOscillator('sine', baseFreq * 1.5, 0.1, 0.15), 50);
                setTimeout(() => this.createOscillator('sine', baseFreq * 2, 0.1, 0.1), 100);
            }
            playAchievement() { [523, 659, 784, 1047, 784, 1047, 1319].forEach((f, i) => setTimeout(() => this.createOscillator('sine', f, 0.2, 0.18), i * 100)); }
            playGoalComplete() {
                [392, 523, 659, 784, 1047, 1319, 1568].forEach((f, i) => setTimeout(() => {
                    this.createOscillator('sine', f, 0.2, 0.2);
                    if (i > 3) this.createOscillator('triangle', f * 2, 0.15, 0.1);
                }, i * 80));
            }
            playUpgrade() {
                this.createOscillator('sine', 400, 0.1, 0.15);
                setTimeout(() => this.createOscillator('sine', 600, 0.1, 0.15), 80);
                setTimeout(() => this.createOscillator('sine', 800, 0.15, 0.2), 160);
            }
            playEventAlert() { for (let i = 0; i < 3; i++) setTimeout(() => this.createOscillator('sine', 880, 0.1, 0.2), i * 200); }
            
            // ËÉåÊôØÈü≥‰πê
            startBGM() {
                if (!this.initialized || !this.musicEnabled) return;
                if (this.bgmInterval) clearInterval(this.bgmInterval);
                const patterns = [
                    [262, 294, 330, 392, 440, 392, 330, 294],
                    [330, 392, 440, 523, 440, 392, 330, 262],
                    [392, 440, 523, 587, 523, 440, 392, 330],
                    [294, 330, 392, 440, 392, 330, 294, 262],
                ];
                let pIdx = 0, nIdx = 0;
                const playNote = () => {
                    if (!this.musicEnabled) return;
                    const freq = patterns[pIdx][nIdx];
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    osc.connect(gain);
                    gain.connect(this.musicGain);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.5);
                    if (nIdx % 2 === 0) {
                        const osc2 = this.audioContext.createOscillator();
                        const gain2 = this.audioContext.createGain();
                        osc2.type = 'triangle';
                        osc2.frequency.value = freq / 2;
                        gain2.gain.setValueAtTime(0.04, this.audioContext.currentTime);
                        gain2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.6);
                        osc2.connect(gain2);
                        gain2.connect(this.musicGain);
                        osc2.start();
                        osc2.stop(this.audioContext.currentTime + 0.7);
                    }
                    nIdx++;
                    if (nIdx >= patterns[pIdx].length) { nIdx = 0; pIdx = (pIdx + 1) % patterns.length; }
                };
                this.bgmInterval = setInterval(playNote, 500);
                playNote();
            }
            stopBGM() {
                if (this.bgmInterval) { clearInterval(this.bgmInterval); this.bgmInterval = null; }
            }
            
            // Èü≥ÈáèÊéßÂà∂
            setMasterVolume(v) { if (this.masterGain) this.masterGain.gain.value = v; }
            setMusicVolume(v) { this.musicVolume = v; if (this.musicGain) this.musicGain.gain.value = v; }
            setSFXVolume(v) { this.sfxVolume = v; if (this.sfxGain) this.sfxGain.gain.value = v; }
            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) this.masterGain.gain.value = this.isMuted ? 0 : 0.8;
                return this.isMuted;
            }
            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                this.musicEnabled ? this.startBGM() : this.stopBGM();
                return this.musicEnabled;
            }
            toggleSFX() {
                this.sfxEnabled = !this.sfxEnabled;
                if (!this.sfxEnabled) this.stopAllLoops();
                return this.sfxEnabled;
            }
            stopAllLoops() {
                this.stopSizzleLoop();
                this.stopBoilLoop();
                this.stopSteamLoop();
                this.stopGrillLoop();
            }
            stopAll() { this.stopBGM(); this.stopAllLoops(); }
        }
        
        const soundManager = new SoundManager();
        
        // ============ Ê∏∏ÊàèÁä∂ÊÄÅ ============
        const gameState = {
            money: 100,
            reputation: 0,
            level: 1,
            day: 1,
            combo: 0,
            maxCombo: 0,
            totalDishesServed: 0,
            autoServe: false,
            
            // ÊØèÊó•ÁõÆÊ†á
            dailyGoal: { target: 10, current: 0, reward: 200 },
            
            // ÂçáÁ∫ßÁ≠âÁ∫ß
            upgrades: {
                speed: 0,
                tips: 0,
                stations: 1
            },
            
            // ÂΩìÂâçÈÄâÊã©
            selectedCustomer: null,
            selectedIngredients: [],
            
            // ÁÉπÈ•™‰∏≠ÁöÑËèúÂìÅ
            cookingDishes: {},
            
            // ÂΩìÂâçÈ°æÂÆ¢ÈòüÂàó
            customers: [],
            
            // Ê∏∏ÊàèÊó∂Èó¥Á≥ªÁªü (Ê®°ÊãüÈ§êÂéÖËê•‰∏öÊó∂Èó¥ 7:00-22:00)
            gameTime: {
                hour: 7,
                minute: 0,
                lastSpawnTime: 0 // ‰∏äÊ¨°ÁîüÊàêÈ°æÂÆ¢ÁöÑÊó∂Èó¥Êà≥
            },
            
            // ÂæÆÊ∏∏ÊàèÈîÅÂÆöÁä∂ÊÄÅ
            isMiniGameActive: false
        };
        
        // ============ È£üÊùêÊï∞ÊçÆ ============
        const ingredients = {
            tofu: { name: 'Ë±ÜËÖê', icon: 'üßà' },
            pork: { name: 'Áå™ËÇâ', icon: 'ü•©' },
            chicken: { name: 'È∏°ËÇâ', icon: 'üçó' },
            beef: { name: 'ÁâõËÇâ', icon: 'ü•ì' },
            fish: { name: 'È±º', icon: 'üêü' },
            shrimp: { name: 'Ëôæ', icon: 'ü¶ê' },
            rice: { name: 'Á±≥È•≠', icon: 'üçö' },
            noodles: { name: 'Èù¢Êù°', icon: 'üçú' },
            flour: { name: 'Èù¢Á≤â', icon: 'üåæ' },
            egg: { name: 'È∏°Ëõã', icon: 'ü•ö' },
            vegetables: { name: 'ÈùíËèú', icon: 'ü•¨' },
            mushroom: { name: 'È¶ôËèá', icon: 'üçÑ' },
            peanut: { name: 'Ëä±Áîü', icon: 'ü•ú' },
            chili: { name: 'Ëæ£Ê§í', icon: 'üå∂Ô∏è' },
            ginger: { name: 'Âßú', icon: 'ü´ö' },
            garlic: { name: 'Â§ßËíú', icon: 'üßÑ' },
            soy_sauce: { name: 'ÈÖ±Ê≤π', icon: 'ü´ó' },
            vinegar: { name: 'ÈÜã', icon: 'üç∂' },
            sugar: { name: 'Á≥ñ', icon: 'üßÇ' },
            bamboo: { name: 'Á´πÁ¨ã', icon: 'üéã' },
            cabbage: { name: 'ÁôΩËèú', icon: 'ü•ó' },
            spring_onion: { name: 'Ëë±', icon: 'üßÖ' },
            duck: { name: 'È∏≠ËÇâ', icon: 'ü¶Ü' },
            crab: { name: 'ËûÉËüπ', icon: 'ü¶Ä' },
            tomato: { name: 'Áï™ËåÑ', icon: 'üçÖ' },
        };
        
        // ============ ËèúÁ≥ªÂíåËèúÂìÅÊï∞ÊçÆ ============
        // ÁÉπÈ•™Ê≠•È™§ËØ¥ÊòéÔºö
        // cutting-ÂàáËèú, stirFry-ÁøªÁÇí, frying-Ê≤πÁÇ∏, seasoning-Ë∞ÉÂë≥, steaming-Ëí∏Âà∂
        // boiling-ÁÖÆÁÇñ, panFry-ÁÖéÂà∂, marinating-ËÖåÂà∂, plating-ÊëÜÁõò, grilling-ÁÉßÁÉ§
        // mixing-ÊêÖÊãå, kneading-ÊèâÈù¢
        
        const cuisines = {
            // ========== ÂÆ∂Â∏∏Â∞èËèú (1Á∫ßËß£ÈîÅÔºåÁÆÄÂçïÂø´ÈÄü) ==========
            homestyle: {
                name: 'ÂÆ∂Â∏∏Ëèú',
                icon: 'üè†',
                unlockLevel: 1,
                dishes: {
                    fried_egg: {
                        name: 'ÁÖéÈ∏°Ëõã',
                        icon: 'üç≥',
                        price: 8,
                        ingredients: ['egg', 'spring_onion', 'soy_sauce'],
                        unlockLevel: 1,
                        cookingSteps: ['panFry', 'plating'],
                        // ÁÖéËõã ‚Üí Ë£ÖÁõò (2Ê≠•ÔºåÊúÄÁÆÄÂçï)
                        difficulty: 1
                    },
                    scrambled_eggs_tomato: {
                        name: 'Áï™ËåÑÁÇíËõã',
                        icon: 'üçÖ',
                        price: 15,
                        ingredients: ['egg', 'vegetables', 'sugar'],
                        unlockLevel: 1,
                        cookingSteps: ['cutting', 'mixing', 'stirFry'],
                        // ÂàáÁï™ËåÑ ‚Üí ÊâìËõã ‚Üí ÁøªÁÇí (3Ê≠•)
                        difficulty: 2
                    },
                    stir_fry_vegetables: {
                        name: 'Ê∏ÖÁÇíÊó∂Ëî¨',
                        icon: 'ü•¨',
                        price: 12,
                        ingredients: ['vegetables', 'garlic', 'soy_sauce'],
                        unlockLevel: 1,
                        cookingSteps: ['cutting', 'stirFry', 'seasoning'],
                        // ÂàáËèú ‚Üí ÁøªÁÇí ‚Üí Ë∞ÉÂë≥ (3Ê≠•)
                        difficulty: 2
                    },
                    steamed_egg: {
                        name: 'Ëí∏Ê∞¥Ëõã',
                        icon: 'ü•ö',
                        price: 10,
                        ingredients: ['egg', 'spring_onion', 'soy_sauce'],
                        unlockLevel: 1,
                        cookingSteps: ['mixing', 'steaming', 'seasoning'],
                        // ÊâìËõãË∞ÉÊ∞¥ ‚Üí Ëí∏Âà∂ ‚Üí Ê∑ãÈÖ±Ê≤π (3Ê≠•)
                        difficulty: 2
                    },
                    garlic_vegetables: {
                        name: 'ËíúËìâËèúÂøÉ',
                        icon: 'ü•¶',
                        price: 14,
                        ingredients: ['vegetables', 'garlic', 'soy_sauce'],
                        unlockLevel: 1,
                        cookingSteps: ['cutting', 'boiling', 'stirFry', 'plating'],
                        // ÂàáËèú ‚Üí ÁÑØÊ∞¥ ‚Üí ÁàÜËíú ‚Üí Ë£ÖÁõò (4Ê≠•)
                        difficulty: 2
                    }
                }
            },
            
            // ========== Â∑ùËèú (1Á∫ßËß£ÈîÅÔºå‰∏≠Á≠âÂ§çÊùÇÂ∫¶) ==========
            sichuan: {
                name: 'Â∑ùËèú',
                icon: 'üå∂Ô∏è',
                unlockLevel: 1,
                dishes: {
                    mapo_tofu: {
                        name: 'È∫ªÂ©ÜË±ÜËÖê',
                        icon: 'ü•ò',
                        price: 25,
                        ingredients: ['tofu', 'pork', 'chili'],
                        unlockLevel: 1,
                        cookingSteps: ['cutting', 'boiling', 'stirFry', 'seasoning'],
                        // ÂàáË±ÜËÖêÂùó ‚Üí ÁÑØÊ∞¥ ‚Üí ÁÇíËÇâÊú´ ‚Üí Ë∞ÉÂë≥ÂãæËä° (4Ê≠•)
                        difficulty: 3
                    },
                    kung_pao_chicken: {
                        name: 'ÂÆ´‰øùÈ∏°‰∏Å',
                        icon: 'üçó',
                        price: 30,
                        ingredients: ['chicken', 'peanut', 'chili'],
                        unlockLevel: 1,
                        cookingSteps: ['cutting', 'marinating', 'stirFry', 'seasoning', 'plating'],
                        // ÂàáÈ∏°‰∏Å ‚Üí ËÖåÂà∂ ‚Üí ÁàÜÁÇí ‚Üí Ë∞ÉÂë≥ ‚Üí ÊëÜÁõò (5Ê≠•)
                        difficulty: 4
                    },
                    fish_fragrant_pork: {
                        name: 'È±ºÈ¶ôËÇâ‰∏ù',
                        icon: 'ü•¢',
                        price: 28,
                        ingredients: ['pork', 'bamboo', 'chili'],
                        unlockLevel: 2,
                        cookingSteps: ['cutting', 'marinating', 'stirFry', 'seasoning'],
                        // Âàá‰∏ù ‚Üí ËÖåÂà∂ ‚Üí ÁÇíÂà∂ ‚Üí Ë∞ÉÈ±ºÈ¶ôÊ±Å (4Ê≠•)
                        difficulty: 3
                    },
                    dan_dan_noodles: {
                        name: 'ÊãÖÊãÖÈù¢',
                        icon: 'üçú',
                        price: 22,
                        ingredients: ['noodles', 'pork', 'chili'],
                        unlockLevel: 2,
                        cookingSteps: ['boiling', 'stirFry', 'seasoning'],
                        // ÁÖÆÈù¢ ‚Üí ÁÇíËÇâËáä ‚Üí Ë∞ÉÂë≥ÊãåÂåÄ (3Ê≠•)
                        difficulty: 2
                    },
                    twice_cooked_pork: {
                        name: 'ÂõûÈîÖËÇâ',
                        icon: 'ü•ì',
                        price: 32,
                        ingredients: ['pork', 'cabbage', 'chili'],
                        unlockLevel: 2,
                        cookingSteps: ['boiling', 'cutting', 'stirFry', 'stirFry', 'seasoning'],
                        // ÁÖÆÁÜü ‚Üí ÂàáÁâá ‚Üí ÁÖ∏ÁÇíËÇâ ‚Üí ÁÇíÈÖçËèú ‚Üí Ë∞ÉÂë≥ (5Ê≠•)
                        difficulty: 4
                    },
                    spicy_chicken: {
                        name: 'Ëæ£Â≠êÈ∏°',
                        icon: 'üêî',
                        price: 35,
                        ingredients: ['chicken', 'chili', 'peanut'],
                        unlockLevel: 3,
                        cookingSteps: ['cutting', 'marinating', 'frying', 'stirFry', 'seasoning', 'plating'],
                        // ÂàáÂùó ‚Üí ËÖåÂà∂ ‚Üí Ê≤πÁÇ∏ ‚Üí ÁàÜÁÇí ‚Üí Ë∞ÉÂë≥ ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    }
                }
            },
            
            // ========== Á≤§Ëèú (3Á∫ßËß£ÈîÅÔºåËÆ≤Á©∂ÁÅ´ÂÄô) ==========
            cantonese: {
                name: 'Á≤§Ëèú',
                icon: 'ü•ü',
                unlockLevel: 3,
                dishes: {
                    white_cut_chicken: {
                        name: 'ÁôΩÂàáÈ∏°',
                        icon: 'üêî',
                        price: 32,
                        ingredients: ['chicken', 'ginger', 'spring_onion'],
                        unlockLevel: 3,
                        cookingSteps: ['boiling', 'cutting', 'plating'],
                        // Êµ∏ÁÖÆ ‚Üí Êñ©‰ª∂ ‚Üí ÊëÜÁõò (3Ê≠•Ôºå‰ΩÜË¶ÅÊ±ÇÁ≤æÂáÜ)
                        difficulty: 3
                    },
                    char_siu: {
                        name: 'ÂèâÁÉß',
                        icon: 'üçñ',
                        price: 35,
                        ingredients: ['pork', 'soy_sauce', 'sugar'],
                        unlockLevel: 3,
                        cookingSteps: ['cutting', 'marinating', 'grilling', 'seasoning', 'cutting', 'plating'],
                        // ÂàáÊù° ‚Üí ËÖåÂà∂ÂÖ•Âë≥ ‚Üí ÁÉ§Âà∂ ‚Üí Âà∑ËúúÊ±Å ‚Üí ÂàáÁâá ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    },
                    dim_sum: {
                        name: 'ËôæÈ•∫',
                        icon: 'ü•ü',
                        price: 28,
                        ingredients: ['shrimp', 'flour', 'bamboo'],
                        unlockLevel: 3,
                        cookingSteps: ['cutting', 'mixing', 'kneading', 'plating', 'steaming'],
                        // ÂàáËôæ‰ªÅ ‚Üí Ë∞ÉÈ¶Ö ‚Üí ÂíåÈù¢ÊìÄÁöÆ ‚Üí ÂåÖÈ•∫Â≠ê ‚Üí Ëí∏Âà∂ (5Ê≠•)
                        difficulty: 4
                    },
                    steamed_fish: {
                        name: 'Ê∏ÖËí∏È±º',
                        icon: 'üêü',
                        price: 40,
                        ingredients: ['fish', 'ginger', 'spring_onion'],
                        unlockLevel: 4,
                        cookingSteps: ['cutting', 'marinating', 'steaming', 'seasoning', 'plating'],
                        // Â§ÑÁêÜÈ±ºË∫´ ‚Üí ÂßúËë±ËÖåÂà∂ ‚Üí Ëí∏Âà∂ ‚Üí Ê∑ãÁÉ≠Ê≤π ‚Üí ÊëÜÁõò (5Ê≠•)
                        difficulty: 4
                    },
                    siu_mai: {
                        name: 'ÁÉßÂçñ',
                        icon: 'ü•ü',
                        price: 25,
                        ingredients: ['pork', 'shrimp', 'flour'],
                        unlockLevel: 4,
                        cookingSteps: ['cutting', 'mixing', 'kneading', 'steaming'],
                        // ÂàáÈ¶ÖÊñô ‚Üí Ë∞ÉÈ¶Ö ‚Üí ÂåÖÁÉßÂçñ ‚Üí Ëí∏Âà∂ (4Ê≠•)
                        difficulty: 3
                    },
                    roast_goose: {
                        name: 'ÁÉßÈπÖ',
                        icon: 'ü¶Ü',
                        price: 55,
                        ingredients: ['duck', 'soy_sauce', 'sugar'],
                        unlockLevel: 5,
                        cookingSteps: ['marinating', 'boiling', 'grilling', 'grilling', 'cutting', 'plating'],
                        // ËÖåÂà∂ ‚Üí ÁÉ´ÁöÆ ‚Üí ÁÉ§Âà∂ ‚Üí ‰∏äËâ≤ ‚Üí Êñ©‰ª∂ ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    }
                }
            },
            
            // ========== ÊπòËèú (4Á∫ßËß£ÈîÅÔºåÈáçÂè£Âë≥) ==========
            hunan: {
                name: 'ÊπòËèú',
                icon: 'üî•',
                unlockLevel: 4,
                dishes: {
                    stir_fry_pork_pepper: {
                        name: 'Â∞èÁÇíËÇâ',
                        icon: 'ü•©',
                        price: 28,
                        ingredients: ['pork', 'chili', 'garlic'],
                        unlockLevel: 4,
                        cookingSteps: ['cutting', 'stirFry', 'seasoning'],
                        // ÂàáÁâá ‚Üí ÁàÜÁÇí ‚Üí Ë∞ÉÂë≥ (3Ê≠•ÔºåÁªèÂÖ∏ÂÆ∂Â∏∏)
                        difficulty: 2
                    },
                    chairman_pork: {
                        name: 'ÊØõÊ∞èÁ∫¢ÁÉßËÇâ',
                        icon: 'ü•©',
                        price: 38,
                        ingredients: ['pork', 'soy_sauce', 'sugar'],
                        unlockLevel: 4,
                        cookingSteps: ['cutting', 'boiling', 'panFry', 'seasoning', 'boiling', 'plating'],
                        // ÂàáÂùó ‚Üí ÁÑØÊ∞¥ ‚Üí ÁÖé‰∏äËâ≤ ‚Üí Ë∞ÉÂë≥ ‚Üí ÁÇñÁÖÆÊî∂Ê±Å ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    },
                    steamed_fish_head: {
                        name: 'ÂâÅÊ§íÈ±ºÂ§¥',
                        icon: 'üêü',
                        price: 42,
                        ingredients: ['fish', 'chili', 'ginger'],
                        unlockLevel: 4,
                        cookingSteps: ['cutting', 'marinating', 'cutting', 'plating', 'steaming', 'seasoning'],
                        // Â§ÑÁêÜÈ±ºÂ§¥ ‚Üí ËÖåÂà∂ ‚Üí ÂâÅÊ§í ‚Üí Èì∫Êñô ‚Üí Ëí∏Âà∂ ‚Üí Ê∑ãÁÉ≠Ê≤π (6Ê≠•)
                        difficulty: 5
                    },
                    changsha_stinky_tofu: {
                        name: 'Ëá≠Ë±ÜËÖê',
                        icon: 'üßà',
                        price: 18,
                        ingredients: ['tofu', 'chili', 'garlic'],
                        unlockLevel: 4,
                        cookingSteps: ['frying', 'seasoning', 'plating'],
                        // Ê≤πÁÇ∏ ‚Üí Ë∞ÉÈÖ± ‚Üí Ë£ÖÁõò (3Ê≠•)
                        difficulty: 2
                    }
                }
            },
            
            // ========== ‰∫¨Ëèú (5Á∫ßËß£ÈîÅÔºåÂÆ´Âª∑Ëèú) ==========
            beijing: {
                name: '‰∫¨Ëèú',
                icon: 'ü¶Ü',
                unlockLevel: 5,
                dishes: {
                    zhajiang_noodles: {
                        name: 'ÁÇ∏ÈÖ±Èù¢',
                        icon: 'üçú',
                        price: 22,
                        ingredients: ['noodles', 'pork', 'soy_sauce'],
                        unlockLevel: 5,
                        cookingSteps: ['cutting', 'stirFry', 'seasoning', 'boiling', 'plating'],
                        // ÂàáËÇâ‰∏Å ‚Üí ÁÇíËÇâ ‚Üí ÁÜ¨ÈÖ± ‚Üí ÁÖÆÈù¢ ‚Üí ÊãåÈù¢Ë£ÖÁ¢ó (5Ê≠•)
                        difficulty: 4
                    },
                    lamb_hotpot: {
                        name: 'Ê∂ÆÁæäËÇâ',
                        icon: 'üç≤',
                        price: 48,
                        ingredients: ['beef', 'vegetables', 'spring_onion'],
                        unlockLevel: 5,
                        cookingSteps: ['cutting', 'cutting', 'boiling', 'plating'],
                        // ÂàáËÇâÁâá ‚Üí ÂàáÈÖçËèú ‚Üí ÁÖÆÈîÖÂ∫ï ‚Üí ÊëÜÁõò‰∏äÊ°å (4Ê≠•)
                        difficulty: 3
                    },
                    peking_duck: {
                        name: 'Âåó‰∫¨ÁÉ§È∏≠',
                        icon: 'ü¶Ü',
                        price: 68,
                        ingredients: ['duck', 'flour', 'spring_onion'],
                        unlockLevel: 5,
                        cookingSteps: ['marinating', 'boiling', 'grilling', 'grilling', 'cutting', 'kneading', 'plating'],
                        // ËÖåÂà∂ ‚Üí ÁÉ´ÁöÆ‰∏äËâ≤ ‚Üí ÁÉ§Âà∂ ‚Üí ÂÜçÁÉ§Ëá≥ÈÖ•ËÑÜ ‚Üí ÁâáÈ∏≠ ‚Üí ÂÅöËñÑÈ•º ‚Üí ÊëÜÁõò (7Ê≠•ÔºåÊúÄÂ§çÊùÇ)
                        difficulty: 6
                    },
                    kung_pao_diced_chicken_beijing: {
                        name: 'ÂÆ´Âª∑ÈÖ±ÁàÜÈ∏°',
                        icon: 'üçó',
                        price: 38,
                        ingredients: ['chicken', 'soy_sauce', 'sugar'],
                        unlockLevel: 6,
                        cookingSteps: ['cutting', 'marinating', 'frying', 'stirFry', 'seasoning', 'plating'],
                        // Âàá‰∏Å ‚Üí ËÖåÂà∂ ‚Üí ËøáÊ≤π ‚Üí ÁàÜÁÇí ‚Üí Ë∞ÉÂë≥ ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    }
                }
            },
            
            // ========== ËãèËèú (6Á∫ßËß£ÈîÅÔºåÁ≤æËá¥Ê∑ÆÊâ¨) ==========
            jiangsu: {
                name: 'ËãèËèú',
                icon: 'ü¶Ä',
                unlockLevel: 6,
                dishes: {
                    yangzhou_rice: {
                        name: 'Êâ¨Â∑ûÁÇíÈ•≠',
                        icon: 'üçö',
                        price: 25,
                        ingredients: ['rice', 'egg', 'shrimp'],
                        unlockLevel: 6,
                        cookingSteps: ['cutting', 'mixing', 'stirFry', 'seasoning'],
                        // Âàá‰∏Å ‚Üí ÊâìËõã ‚Üí ÁÇíÈ•≠ ‚Üí Ë∞ÉÂë≥ (4Ê≠•)
                        difficulty: 3
                    },
                    lion_head: {
                        name: 'ÁãÆÂ≠êÂ§¥',
                        icon: 'ü•©',
                        price: 36,
                        ingredients: ['pork', 'cabbage', 'ginger'],
                        unlockLevel: 6,
                        cookingSteps: ['cutting', 'mixing', 'kneading', 'panFry', 'boiling', 'plating'],
                        // ÂâÅËÇâÁ≥ú ‚Üí Ë∞ÉÂë≥ÊêÖÊâì ‚Üí ÊêìËÇâ‰∏∏ ‚Üí ÁÖéÂÆöÂûã ‚Üí ÁÇñÁÖÆ ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    },
                    sweet_sour_ribs: {
                        name: 'Á≥ñÈÜãÊéíÈ™®',
                        icon: 'üçñ',
                        price: 32,
                        ingredients: ['pork', 'sugar', 'vinegar'],
                        unlockLevel: 6,
                        cookingSteps: ['cutting', 'marinating', 'frying', 'stirFry', 'seasoning'],
                        // ÂàáÊÆµ ‚Üí ËÖåÂà∂ ‚Üí Ê≤πÁÇ∏ ‚Üí ÁøªÁÇí ‚Üí Ë£πÁ≥ñÈÜãÊ±Å (5Ê≠•)
                        difficulty: 4
                    },
                    hairy_crab: {
                        name: 'Â§ßÈó∏Ëüπ',
                        icon: 'ü¶Ä',
                        price: 78,
                        ingredients: ['crab', 'ginger', 'vinegar'],
                        unlockLevel: 7,
                        cookingSteps: ['cutting', 'steaming', 'plating'],
                        // ÂàáÂßú‰∏ù ‚Üí Ëí∏Ëüπ ‚Üí ÊëÜÁõòÈÖçËò∏Êñô (3Ê≠•ÔºåÁÆÄÂçï‰ΩÜÈ£üÊùêÁèçË¥µ)
                        difficulty: 2
                    },
                    squirrel_fish: {
                        name: 'ÊùæÈº†È≥úÈ±º',
                        icon: 'üêü',
                        price: 58,
                        ingredients: ['fish', 'sugar', 'vinegar'],
                        unlockLevel: 7,
                        cookingSteps: ['cutting', 'cutting', 'marinating', 'frying', 'stirFry', 'seasoning', 'plating'],
                        // ÂâûËä±ÂàÄ ‚Üí ÊîπÂàÄ ‚Üí ËÖåÂà∂ ‚Üí Ê≤πÁÇ∏ÂÆöÂûã ‚Üí ÁÇíÁ≥ñÈÜãÊ±Å ‚Üí Ê∑ãÊ±Å ‚Üí ÊëÜÁõò (7Ê≠•)
                        difficulty: 6
                    }
                }
            },
            
            // ========== È≤ÅËèú (7Á∫ßËß£ÈîÅÔºåÂåóÊñπÂ§ßËèú) ==========
            shandong: {
                name: 'È≤ÅËèú',
                icon: 'ü¶ê',
                unlockLevel: 7,
                dishes: {
                    braised_prawns: {
                        name: 'Ê≤πÁÑñÂ§ßËôæ',
                        icon: 'ü¶ê',
                        price: 45,
                        ingredients: ['shrimp', 'soy_sauce', 'sugar'],
                        unlockLevel: 7,
                        cookingSteps: ['cutting', 'panFry', 'seasoning', 'boiling', 'plating'],
                        // Â§ÑÁêÜËôæ ‚Üí ÁÖéÂà∂ ‚Üí Ë∞ÉÂë≥ ‚Üí ÁÑñÁÖÆ ‚Üí ÊëÜÁõò (5Ê≠•)
                        difficulty: 4
                    },
                    sweet_sour_carp: {
                        name: 'Á≥ñÈÜãÈ≤§È±º',
                        icon: 'üêü',
                        price: 52,
                        ingredients: ['fish', 'sugar', 'vinegar'],
                        unlockLevel: 7,
                        cookingSteps: ['cutting', 'cutting', 'marinating', 'frying', 'stirFry', 'seasoning', 'plating'],
                        // ÂâûËä±ÂàÄ ‚Üí ÊîπÂàÄ ‚Üí ËÖåÂà∂ ‚Üí Ê≤πÁÇ∏ ‚Üí ÁÇíÊ±Å ‚Üí ÊµáÊ±Å ‚Üí ÊëÜÁõò (7Ê≠•)
                        difficulty: 6
                    },
                    dezhou_chicken: {
                        name: 'Âæ∑Â∑ûÊâíÈ∏°',
                        icon: 'üêî',
                        price: 48,
                        ingredients: ['chicken', 'soy_sauce', 'sugar'],
                        unlockLevel: 8,
                        cookingSteps: ['marinating', 'frying', 'boiling', 'boiling', 'cutting', 'plating'],
                        // ËÖåÂà∂ ‚Üí Ê≤πÁÇ∏‰∏äËâ≤ ‚Üí Âç§ÁÖÆ ‚Üí Êî∂Ê±Å ‚Üí Êñ©‰ª∂ ‚Üí ÊëÜÁõò (6Ê≠•)
                        difficulty: 5
                    }
                }
            }
        };
        
        // Ëé∑ÂèñÁÉπÈ•™Ê≠•È™§ÊèèËø∞
        function getStepDescription(step) {
            const descriptions = {
                cutting: 'üî™ ÂàáËèú - Â§ÑÁêÜÈ£üÊùê',
                stirFry: 'ü•ò ÁøªÁÇí - Â§ßÁÅ´Âø´ÁÇí',
                frying: 'üçü Ê≤πÁÇ∏ - ÈÖ•ËÑÜÈáëÈªÑ',
                seasoning: 'üßÇ Ë∞ÉÂë≥ - Âí∏È≤úÈÄÇÂè£',
                steaming: '‚ô®Ô∏è Ëí∏Âà∂ - ÂéüÊ±ÅÂéüÂë≥',
                boiling: 'üç≤ ÁÖÆÁÇñ - ÊÖ¢ÁÅ´ÂÖ•Âë≥',
                panFry: 'üç≥ ÁÖéÂà∂ - ‰∏§Èù¢ÈáëÈªÑ',
                marinating: 'ü•£ ËÖåÂà∂ - ÂÖ•Âë≥ÊèêÈ≤ú',
                plating: 'üçΩÔ∏è ÊëÜÁõò - ÁæéËßÇÂëàÁé∞',
                grilling: 'üî• ÁÉßÁÉ§ - ÁÑ¶È¶ôÂõõÊ∫¢',
                mixing: 'ü•Ñ ÊêÖÊãå - ÂùáÂåÄÊ∑∑Âêà',
                kneading: 'ü´ì ÊèâÈù¢ - Á≠ãÈÅìQÂºπ'
            };
            return descriptions[step] || step;
        }
        
        // ËÆ°ÁÆóËèúÂìÅÂü∫Á°ÄÁÉπÈ•™Êó∂Èó¥ÔºàÊØ´ÁßíÔºâ- ÊØè‰∏™Ê≠•È™§Â§ßÁ∫¶3-5Áßí
        function getBaseCookingTime(dishId) {
            const steps = getCookingStepsForDish(dishId);
            const stepCount = steps.length;
            // ÊØèÊ≠•Âü∫Á°Ä3ÁßíÔºåÂ§çÊùÇÊ≠•È™§È¢ùÂ§ñÂä†Êó∂
            const complexSteps = ['marinating', 'boiling', 'steaming', 'grilling'];
            let totalTime = 0;
            steps.forEach(step => {
                if (complexSteps.includes(step)) {
                    totalTime += 4000; // Â§çÊùÇÊ≠•È™§4Áßí
                } else {
                    totalTime += 3000; // ÁÆÄÂçïÊ≠•È™§3Áßí
                }
            });
            return totalTime;
        }
        
        // Ëé∑ÂèñËèúÂìÅÁöÑÁÉπÈ•™Ê≠•È™§
        function getCookingStepsForDish(dishId) {
            for (const [cuisineId, cuisine] of Object.entries(cuisines)) {
                if (cuisine.dishes[dishId]) {
                    return cuisine.dishes[dishId].cookingSteps || ['cutting', 'stirFry', 'seasoning'];
                }
            }
            return ['cutting', 'stirFry', 'seasoning'];
        }
        
        // ============ È°æÂÆ¢Á±ªÂûã ============
        const customerTypes = [
            { avatar: 'üë®', patience: 1.0, tip: 1.0, name: 'ÊôÆÈÄöÈ°æÂÆ¢' },
            { avatar: 'üë©', patience: 1.0, tip: 1.0, name: 'ÊôÆÈÄöÈ°æÂÆ¢' },
            { avatar: 'üë¥', patience: 1.4, tip: 1.2, name: 'ËÄêÂøÉËÄÅËÄÖ' },
            { avatar: 'üëµ', patience: 1.4, tip: 1.2, name: 'ÊÖàÁ••Â•∂Â•∂' },
            { avatar: 'üë¶', patience: 0.7, tip: 0.8, name: 'ÊÄ•Ë∫ÅÂ∞èÂ≠©' },
            { avatar: 'üßë‚Äçüíº', patience: 0.6, tip: 1.5, name: 'ÂïÜÂä°‰∫∫Â£´' },
            { avatar: 'üë®‚Äçüç≥', patience: 1.2, tip: 2.0, name: 'ÁæéÈ£üËØÑËÆ∫ÂÆ∂', special: true },
            { avatar: 'üë∏', patience: 0.5, tip: 2.5, name: 'ÊåëÂâîÂÖ¨‰∏ª', special: true },
            { avatar: 'üßì', patience: 1.5, tip: 1.3, name: 'ÁæéÈ£üÂÆ∂' },
        ];
        
        // ============ ÁâπÊÆä‰∫ã‰ª∂ ============
        const specialEvents = [
            {
                id: 'beggar',
                icon: 'üßë‚Äçü¶Ø',
                title: 'È••È•øÁöÑ‰πû‰∏ê',
                desc: '‰∏Ä‰ΩçÈ••È•øÁöÑ‰πû‰∏êÊù•Âà∞Â∫óÈó®Âè£ÔºåÂ∏åÊúõËÉΩÂæóÂà∞‰∏Ä‰∫õÈ£üÁâ©...',
                options: [
                    { text: 'Ëµ†ÈÄÅÈ£üÁâ© (-20üí∞)', action: () => { gameState.money -= 20; gameState.reputation += 15; return 'Â•ΩÂøÉÊúâÂ•ΩÊä•ÔºÅÂ£∞Êúõ +15'; }},
                    { text: 'Â©âÊãí', action: () => { return '‰πû‰∏êÂ§±ÊúõÂú∞Á¶ªÂºÄ‰∫Ü'; }, negative: true }
                ]
            },
            {
                id: 'thief',
                icon: 'ü•∑',
                title: 'Â∞èÂÅ∑Âá∫Ê≤°ÔºÅ',
                desc: '‰∏Ä‰∏™ÂèØÁñëÁöÑË∫´ÂΩ±ËØïÂõæÂÅ∑Ëµ∞Êî∂Èì∂Âè∞ÁöÑÈí±ÔºÅÂø´ÁÇπÂáªÊäì‰Ωè‰ªñÔºÅ',
                options: [
                    { text: 'üñêÔ∏è Êäì‰ΩèÂ∞èÂÅ∑ÔºÅ', action: () => { gameState.money += 50; return 'ÊàêÂäüÊäì‰ΩèÂ∞èÂÅ∑ÔºÅËé∑Âæó +50üí∞ Â•ñÂä±ÔºÅ'; }, timed: true },
                ],
                timeout: 3000,
                timeoutAction: () => { gameState.money -= 30; return 'Â∞èÂÅ∑ÈÄÉË∑ë‰∫ÜÔºÅÊçüÂ§± 30üí∞'; }
            },
            {
                id: 'food_critic',
                icon: 'üìù',
                title: 'ÁæéÈ£üËØÑËÆ∫ÂÆ∂Êù•ËÆøÔºÅ',
                desc: 'ËëóÂêçÁæéÈ£üËØÑËÆ∫ÂÆ∂Á™ÅÁÑ∂ÈÄ†ËÆøÔºÅÂ¶ÇÊûúËé∑ÂæóÂ•ΩËØÑÔºåÂ£∞ÊúõÂ∞ÜÂ§ßÂπÖÊèêÂçáÔºÅ',
                options: [
                    { text: 'ÂÖ®Âäõ‰ª•Ëµ¥ÔºÅ', action: () => { 
                        // Ê∑ªÂä†‰∏Ä‰∏™È´òË¶ÅÊ±ÇÁöÑÁâπÊÆäÈ°æÂÆ¢
                        spawnSpecialCustomer('critic');
                        return 'ËØÑËÆ∫ÂÆ∂Â∑≤ÂÖ•Â∫ßÔºåËØ∑ËÆ§ÁúüÊúçÂä°ÔºÅ'; 
                    }}
                ]
            },
            {
                id: 'health_inspector',
                icon: 'üîç',
                title: 'Âç´ÁîüÊ£ÄÊü•Âëò',
                desc: 'Âç´ÁîüÊ£ÄÊü•ÂëòÊù•‰∫ÜÔºÅÈúÄË¶ÅÊîØ‰ªòÊ£ÄÊü•Ë¥πÁî®ÊàñÂÜíÈô©...',
                options: [
                    { text: 'ÈÖçÂêàÊ£ÄÊü• (-50üí∞)', action: () => { gameState.money -= 50; gameState.reputation += 20; return 'Ê£ÄÊü•ÈÄöËøáÔºÅÂ£∞Êúõ +20'; }},
                    { text: 'Á¢∞ËøêÊ∞î', action: () => { 
                        if (Math.random() > 0.5) {
                            gameState.reputation += 30;
                            return 'Âπ∏ËøêÔºÅÂé®ÊàøÂæàÂπ≤ÂáÄÔºåÂ£∞Êúõ +30';
                        } else {
                            gameState.reputation -= 20;
                            return 'ÂèëÁé∞ÈóÆÈ¢òÔºÅÂ£∞Êúõ -20';
                        }
                    }, negative: true }
                ]
            },
            {
                id: 'vip_customer',
                icon: 'üëë',
                title: 'VIP Ë¥µÂÆæÂà∞ËÆøÔºÅ',
                desc: '‰∏Ä‰ΩçÁ•ûÁßòÁöÑVIPË¥µÂÆæÊù•Âà∞‰∫ÜÊÇ®ÁöÑÈ§êÂéÖÔºÅ',
                options: [
                    { text: 'ÁÉ≠ÊÉÖÊé•ÂæÖ', action: () => { 
                        spawnSpecialCustomer('vip');
                        return 'VIPÂ∑≤ÂÖ•Â∫ßÔºå‰ªñ‰ºöÁªô‰∫à‰∏∞ÂéöÂ∞èË¥πÔºÅ'; 
                    }}
                ]
            },
            {
                id: 'lucky_day',
                icon: 'üçÄ',
                title: 'Âπ∏ËøêÊó•ÔºÅ',
                desc: '‰ªäÂ§©ÊòØ‰∏™Â•ΩÊó•Â≠êÔºÅÈ°æÂÆ¢‰ª¨ÂøÉÊÉÖÈÉΩÂæàÂ•ΩÔºÅ',
                options: [
                    { text: 'Â§™Ê£í‰∫ÜÔºÅ', action: () => { 
                        gameState.customers.forEach(c => {
                            c.patience = Math.min(c.maxPatience, c.patience + 50);
                        });
                        return 'ÊâÄÊúâÈ°æÂÆ¢ËÄêÂøÉ +50ÔºÅ'; 
                    }}
                ]
            }
        ];
        
        // ============ ÂçáÁ∫ßÊï∞ÊçÆ ============
        const upgradeData = {
            speed: {
                name: 'ÁÉπÈ•™ÈÄüÂ∫¶',
                icon: '‚ö°',
                desc: 'ÊèêÂçáÁÉπÈ•™ÈÄüÂ∫¶ 20%/Á∫ß',
                maxLevel: 5,
                costs: [100, 200, 400, 800, 1600],
                category: 'basic'
            },
            tips: {
                name: 'ÊúçÂä°ÊÄÅÂ∫¶',
                icon: 'üíù',
                desc: 'ÊèêÂçáÂ∞èË¥π 15%/Á∫ß',
                maxLevel: 5,
                costs: [150, 300, 600, 1200, 2400],
                category: 'basic'
            },
            stations: {
                name: 'ÁÉπÈ•™Âè∞',
                icon: 'üç≥',
                desc: 'Â¢ûÂä†ÁÉπÈ•™Âè∞Êï∞Èáè',
                maxLevel: 4,
                costs: [300, 600, 1200, 2400],
                category: 'basic'
            }
        };
        
        // ============ Ê∏∏ÊàèÂàùÂßãÂåñ ============
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            // ÂàùÂßãÂåñÈü≥ÊïàÁ≥ªÁªü
            soundManager.init().then(() => {
                soundManager.startBGM();
                soundManager.playSuccess();
            });
            initGame();
        }
        
        // ===== Èü≥ÊïàÈù¢ÊùøÊéßÂà∂ =====
        function openSoundPanel() {
            soundManager.resume();
            soundManager.playClick();
            document.getElementById('sound-panel').classList.add('active');
        }
        function closeSoundPanel() {
            soundManager.playClick();
            document.getElementById('sound-panel').classList.remove('active');
        }
        function toggleBGM() {
            const enabled = soundManager.toggleMusic();
            const btn = document.getElementById('bgm-toggle');
            btn.textContent = enabled ? 'ÂºÄ' : 'ÂÖ≥';
            btn.classList.toggle('active', enabled);
            soundManager.playClick();
        }
        function toggleSFX() {
            const enabled = soundManager.toggleSFX();
            const btn = document.getElementById('sfx-toggle');
            btn.textContent = enabled ? 'ÂºÄ' : 'ÂÖ≥';
            btn.classList.toggle('active', enabled);
        }
        function setMusicVolume(v) { soundManager.setMusicVolume(v / 100); }
        function setSFXVolume(v) { soundManager.setSFXVolume(v / 100); }
        
        function initGame() {
            renderIngredients();
            renderCookingStations();
            initCookingCanvas();
            updateUI();
            
            // ÂêØÂä®Ê∏∏ÊàèÂæ™ÁéØ
            setInterval(gameLoop, 100);
            
            // Êô∫ËÉΩÈ°æÂÆ¢ÁîüÊàêÁ≥ªÁªü (Ê†πÊçÆÁî®È§êÊó∂Èó¥È´òÂ≥∞Êúü)
            setInterval(smartSpawnCustomer, 1000);
            
            // ÈöèÊú∫Ëß¶ÂèëÁâπÊÆä‰∫ã‰ª∂
            setInterval(tryTriggerEvent, 15000);
            
            // ÂàùÂßãÁîüÊàê2‰∏™È°æÂÆ¢
            for (let i = 0; i < 2; i++) {
                setTimeout(() => spawnCustomer(), i * 800);
            }
        }
        
        // Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥ÊÆµÁöÑÈ°æÂÆ¢ÁîüÊàêÊ¶ÇÁéá
        function getSpawnChance() {
            const hour = gameState.gameTime.hour;
            
            // Áî®È§êÈ´òÂ≥∞ÊúüÂÆö‰πâ
            // Êó©È§ê: 7:00-9:00 (‰∏≠Á≠â)
            // ÂçàÈ§ê: 11:00-13:00 (È´òÂ≥∞)
            // ‰∏ãÂçàËå∂: 14:00-16:00 (‰Ωé)
            // ÊôöÈ§ê: 17:00-20:00 (È´òÂ≥∞)
            // ÂÆµÂ§ú: 21:00-22:00 (‰∏≠Á≠â)
            // ÂÖ∂‰ªñÊó∂Èó¥: ‰Ωé
            
            if (hour >= 11 && hour < 13) return 0.35; // ÂçàÈ§êÈ´òÂ≥∞ 35%
            if (hour >= 17 && hour < 20) return 0.35; // ÊôöÈ§êÈ´òÂ≥∞ 35%
            if (hour >= 7 && hour < 9) return 0.20;   // Êó©È§ê 20%
            if (hour >= 21 && hour < 22) return 0.20; // ÂÆµÂ§ú 20%
            if (hour >= 14 && hour < 16) return 0.10; // ‰∏ãÂçàËå∂ 10%
            return 0.08; // ÂÖ∂‰ªñÊó∂Èó¥ 8%
        }
        
        // Ëé∑ÂèñÊó∂Èó¥ÊÆµÂêçÁß∞
        function getTimePeriodName() {
            const hour = gameState.gameTime.hour;
            if (hour >= 7 && hour < 9) return 'üåÖ Êó©È§êÊó∂ÊÆµ';
            if (hour >= 11 && hour < 13) return '‚òÄÔ∏è ÂçàÈ§êÈ´òÂ≥∞';
            if (hour >= 14 && hour < 16) return 'üçµ ‰∏ãÂçàËå∂';
            if (hour >= 17 && hour < 20) return 'üåÜ ÊôöÈ§êÈ´òÂ≥∞';
            if (hour >= 21) return 'üåô ÂÆµÂ§úÊó∂ÊÆµ';
            return '‚è∞ ÂáÜÂ§áÊó∂ÊÆµ';
        }
        
        // Êô∫ËÉΩÈ°æÂÆ¢ÁîüÊàê
        function smartSpawnCustomer() {
            // Êõ¥Êñ∞Ê∏∏ÊàèÊó∂Èó¥ (ÊØèÁßíÂ¢ûÂä†2ÂàÜÈíüÊ∏∏ÊàèÊó∂Èó¥)
            gameState.gameTime.minute += 2;
            if (gameState.gameTime.minute >= 60) {
                gameState.gameTime.minute = 0;
                gameState.gameTime.hour++;
                
                // ‰∏ÄÂ§©ÁªìÊùüÔºåÈáçÁΩÆÂà∞Á¨¨‰∫åÂ§©
                if (gameState.gameTime.hour >= 23) {
                    gameState.gameTime.hour = 7;
                    gameState.day++;
                    showToast(`üåÖ Á¨¨ ${gameState.day} Â§©ÂºÄÂßãÔºÅ`, 'success');
                }
            }
            
            // Â¶ÇÊûúÈ°æÂÆ¢Â∑≤Êª°Ôºå‰∏çÁîüÊàê
            if (gameState.customers.length >= 5) return;
            
            // Â¶ÇÊûúÊ≠£Âú®ËøõË°åÂæÆÊ∏∏ÊàèÔºåÈôç‰ΩéÁîüÊàêÊ¶ÇÁéá
            let spawnChance = getSpawnChance();
            if (gameState.isMiniGameActive) {
                spawnChance *= 0.3; // ÂæÆÊ∏∏ÊàèËøõË°å‰∏≠ÔºåÊ¶ÇÁéáÈôç‰Ωé70%
            }
            
            // Ê†πÊçÆÊ¶ÇÁéáÁîüÊàêÈ°æÂÆ¢
            if (Math.random() < spawnChance) {
                spawnCustomer();
            }
        }
        
        // ============ Ê∏∏Êàè‰∏ªÂæ™ÁéØ ============
        function gameLoop() {
            // Êõ¥Êñ∞È°æÂÆ¢ËÄêÂøÉ
            let playedWarning = false;
            gameState.customers.forEach((customer, index) => {
                const wasAbove20 = customer.patience / customer.maxPatience > 0.2;
                customer.patience -= 1;
                const isNow20 = customer.patience / customer.maxPatience <= 0.2;
                
                // ËÄêÂøÉÈôçÂà∞20%Êó∂ÂèëÂá∫Ë≠¶Âëä
                if (wasAbove20 && isNow20 && !playedWarning) {
                    soundManager.playCustomerWarning();
                    playedWarning = true;
                }
                
                if (customer.patience <= 0) {
                    // È°æÂÆ¢Á¶ªÂºÄ
                    customerLeave(index, false);
                }
            });
            
            renderCustomers();
            updateUI();
        }
        
        // ============ Ê∏≤ÊüìÂáΩÊï∞ ============
        function renderIngredients() {
            const grid = document.getElementById('ingredient-grid');
            grid.innerHTML = '';
            
            Object.entries(ingredients).forEach(([id, ing]) => {
                const el = document.createElement('div');
                el.className = 'ingredient' + (gameState.selectedIngredients.includes(id) ? ' selected' : '');
                el.innerHTML = `
                    <div class="ingredient-icon">${ing.icon}</div>
                    <div class="ingredient-name">${ing.name}</div>
                `;
                el.onclick = () => toggleIngredient(id);
                grid.appendChild(el);
            });
        }
        
        function renderCookingStations() {
            const area = document.getElementById('cooking-area');
            area.innerHTML = '';
            
            const maxStations = gameState.upgrades.stations + 1;
            
            for (let i = 0; i < 4; i++) {
                const station = document.createElement('div');
                const locked = i >= maxStations;
                station.className = 'cooking-station' + (locked ? ' locked' : '');
                station.dataset.station = i;
                
                if (locked) {
                    station.innerHTML = `
                        <div class="station-icon">üîí</div>
                        <div class="station-name">ÂçáÁ∫ßËß£ÈîÅ</div>
                    `;
                } else {
                    const cooking = gameState.cookingDishes[i];
                    if (cooking) {
                        station.classList.add('cooking');
                        station.innerHTML = `
                            <div class="station-dish">${cooking.icon}</div>
                            <div class="station-name">${cooking.name}</div>
                            <div class="station-progress active">
                                <div class="station-progress-fill" style="width: ${cooking.progress}%"></div>
                            </div>
                        `;
                    } else {
                        station.innerHTML = `
                            <div class="station-icon">üç≥</div>
                            <div class="station-name">ÁÉπÈ•™Âè∞ ${i + 1}</div>
                        `;
                        station.onclick = () => startCookingAtStation(i);
                    }
                }
                
                area.appendChild(station);
            }
        }
        
        function renderCustomers() {
            const area = document.getElementById('customer-area');
            area.innerHTML = '';
            
            gameState.customers.forEach((customer, index) => {
                const patiencePercent = (customer.patience / customer.maxPatience) * 100;
                const isLow = patiencePercent < 30;
                
                // Ê†πÊçÆËÄêÂøÉÊòæÁ§∫Ë°®ÊÉÖ
                let mood = 'üòä';
                if (patiencePercent < 30) mood = 'üò†';
                else if (patiencePercent < 60) mood = 'üòê';
                
                // Ê†πÊçÆÊ≠•È™§Êï∞ÊòæÁ§∫ÈöæÂ∫¶ÊòüÁ∫ß
                const stepCount = customer.dishStepCount || 3;
                let difficultyStars = '';
                if (stepCount <= 2) difficultyStars = '‚≠ê';
                else if (stepCount <= 3) difficultyStars = '‚≠ê‚≠ê';
                else if (stepCount <= 5) difficultyStars = '‚≠ê‚≠ê‚≠ê';
                else difficultyStars = '‚≠ê‚≠ê‚≠ê‚≠ê';
                
                const el = document.createElement('div');
                el.className = 'customer' + 
                    (gameState.selectedCustomer === index ? ' selected' : '') +
                    (customer.special ? ' special' : '');
                el.innerHTML = `
                    ${customer.tipMultiplier > 1.5 ? `<div class="customer-tip">x${customer.tipMultiplier.toFixed(1)}</div>` : ''}
                    <div class="customer-avatar">
                        ${customer.avatar}
                        <div class="customer-mood">${mood}</div>
                    </div>
                    <div class="customer-order-icon">${customer.dishIcon}</div>
                    <div class="customer-order">${customer.dishName}</div>
                    <div class="customer-steps" style="font-size: 10px; color: #ffd700; margin-bottom: 3px;" title="${stepCount}‰∏™ÁÉπÈ•™Ê≠•È™§">${stepCount}Ê≠• ${difficultyStars}</div>
                    <div class="patience-bar">
                        <div class="patience-fill ${isLow ? 'low' : ''}" style="width: ${patiencePercent}%"></div>
                    </div>
                `;
                el.onclick = () => selectCustomer(index);
                area.appendChild(el);
            });
        }
        
        // ============ È°æÂÆ¢Á≥ªÁªü ============
        function spawnCustomer() {
            if (gameState.customers.length >= 6) return;
            
            // Ëé∑ÂèñÂèØÁî®ËèúÂìÅ
            const availableDishes = [];
            Object.entries(cuisines).forEach(([cuisineId, cuisine]) => {
                if (gameState.level >= cuisine.unlockLevel) {
                    Object.entries(cuisine.dishes).forEach(([dishId, dish]) => {
                        if (gameState.level >= dish.unlockLevel) {
                            availableDishes.push({ cuisineId, dishId, dish });
                        }
                    });
                }
            });
            
            if (availableDishes.length === 0) return;
            
            const randomDish = availableDishes[Math.floor(Math.random() * availableDishes.length)];
            const randomType = customerTypes[Math.floor(Math.random() * customerTypes.length)];
            
            // Ê†πÊçÆÁÉπÈ•™Ê≠•È™§Êï∞ÈáèËÆ°ÁÆóÂü∫Á°ÄËÄêÂøÉÂÄº
            // Ê≠•È™§Ë∂äÂ§öÔºåÈ°æÂÆ¢Á≠âÂæÖÊó∂Èó¥Ë∂äÈïøÔºàÊõ¥ÂêàÁêÜÔºâ
            const cookingSteps = randomDish.dish.cookingSteps || ['cutting', 'stirFry', 'seasoning'];
            const stepCount = cookingSteps.length;
            
            // Âü∫Á°ÄËÄêÂøÉËÆ°ÁÆóÔºö
            // 2Ê≠•Ëèú(ÁÖéÈ∏°Ëõã): 80 + 8*25 + 2*50 = 80 + 200 + 100 = 380
            // 3Ê≠•Ëèú: 80 + 15*25 + 3*50 = 80 + 375 + 150 = 605  
            // 5Ê≠•Ëèú(ÂÆ´‰øùÈ∏°‰∏Å): 80 + 30*25 + 5*50 = 80 + 750 + 250 = 1080
            // 7Ê≠•Ëèú(Âåó‰∫¨ÁÉ§È∏≠): 80 + 58*25 + 7*50 = 80 + 1450 + 350 = 1880
            const basePatience = 80 + randomDish.dish.price * 25 + stepCount * 50;
            
            // ÈöæÂ∫¶Á≥ªÊï∞ÂΩ±Âìç
            const difficultyFactor = randomDish.dish.difficulty || 3;
            const difficultyBonus = difficultyFactor * 15; // ÈöæÂ∫¶Ë∂äÈ´òÈ¢ùÂ§ñËÄêÂøÉË∂äÂ§ö
            
            const finalPatience = (basePatience + difficultyBonus) * randomType.patience;
            
            gameState.customers.push({
                avatar: randomType.avatar,
                dishId: randomDish.dishId,
                dishName: randomDish.dish.name,
                dishIcon: randomDish.dish.icon,
                dishIngredients: randomDish.dish.ingredients,
                dishPrice: randomDish.dish.price,
                dishStepCount: stepCount,
                dishDifficulty: difficultyFactor,
                patience: finalPatience,
                maxPatience: finalPatience,
                tipMultiplier: randomType.tip * (1 + gameState.upgrades.tips * 0.15),
                special: randomType.special || false
            });
            
            soundManager.playCustomerArrive();
            renderCustomers();
        }
        
        function spawnSpecialCustomer(type) {
            const availableDishes = [];
            Object.entries(cuisines).forEach(([cuisineId, cuisine]) => {
                if (gameState.level >= cuisine.unlockLevel) {
                    Object.entries(cuisine.dishes).forEach(([dishId, dish]) => {
                        if (gameState.level >= dish.unlockLevel) {
                            availableDishes.push({ cuisineId, dishId, dish });
                        }
                    });
                }
            });
            
            if (availableDishes.length === 0) return;
            
            // ÈÄâÊã©ÊúÄË¥µÁöÑËèú
            availableDishes.sort((a, b) => b.dish.price - a.dish.price);
            const dish = availableDishes[0];
            const cookingSteps = dish.dish.cookingSteps || ['cutting', 'stirFry', 'seasoning'];
            const stepCount = cookingSteps.length;
            const difficultyFactor = dish.dish.difficulty || 3;
            
            // ÁâπÊÆäÈ°æÂÆ¢ÁöÑËÄêÂøÉËÆ°ÁÆóÔºàÂü∫‰∫éÊ≠•È™§Êï∞Ôºâ
            const basePatience = 150 + stepCount * 60 + difficultyFactor * 20;
            
            let customer;
            if (type === 'critic') {
                customer = {
                    avatar: 'üìù',
                    dishId: dish.dishId,
                    dishName: dish.dish.name,
                    dishIcon: dish.dish.icon,
                    dishIngredients: dish.dish.ingredients,
                    dishPrice: dish.dish.price,
                    dishStepCount: stepCount,
                    dishDifficulty: difficultyFactor,
                    patience: basePatience * 1.2, // ËØÑËÆ∫ÂÆ∂ËÄêÂøÉÁï•È´ò
                    maxPatience: basePatience * 1.2,
                    tipMultiplier: 3.0,
                    special: true,
                    isCritic: true
                };
            } else if (type === 'vip') {
                customer = {
                    avatar: 'üëë',
                    dishId: dish.dishId,
                    dishName: dish.dish.name,
                    dishIcon: dish.dish.icon,
                    dishIngredients: dish.dish.ingredients,
                    dishPrice: dish.dish.price,
                    dishStepCount: stepCount,
                    dishDifficulty: difficultyFactor,
                    patience: basePatience * 1.5, // VIPÊúÄÊúâËÄêÂøÉ
                    maxPatience: basePatience * 1.5,
                    tipMultiplier: 5.0,
                    special: true
                };
            }
            
            gameState.customers.unshift(customer);
            renderCustomers();
        }
        
        function selectCustomer(index) {
            gameState.selectedCustomer = index;
            const customer = gameState.customers[index];
            
            // Ëá™Âä®ÈÄâÊã©ÈúÄË¶ÅÁöÑÈ£üÊùê
            gameState.selectedIngredients = [...customer.dishIngredients];
            
            soundManager.playSelect();
            renderCustomers();
            renderIngredients();
            updateSelectedCount();
            
            // ÊòæÁ§∫ËèúÂìÅ‰ø°ÊÅØÂíåÊ≠•È™§Êï∞
            const stepCount = customer.dishStepCount || 3;
            const difficultyText = stepCount <= 2 ? 'ÁÆÄÂçï' : stepCount <= 4 ? '‰∏≠Á≠â' : stepCount <= 5 ? 'Â§çÊùÇ' : 'È´òÈöæÂ∫¶';
            showToast(`${customer.dishName} (${stepCount}Ê≠•¬∑${difficultyText})`, 'success');
        }
        
        function customerLeave(index, satisfied) {
            const customer = gameState.customers[index];
            
            if (!satisfied) {
                gameState.combo = 0;
                gameState.reputation = Math.max(0, gameState.reputation - 5);
                showToast(`${customer.avatar} ‰∏çËÄêÁÉ¶Âú∞Á¶ªÂºÄ‰∫ÜÔºÅ`, 'error');
                soundManager.playCustomerAngry();
            } else {
                soundManager.playCustomerHappy();
            }
            
            gameState.customers.splice(index, 1);
            
            if (gameState.selectedCustomer === index) {
                gameState.selectedCustomer = null;
            } else if (gameState.selectedCustomer > index) {
                gameState.selectedCustomer--;
            }
            
            renderCustomers();
            updateUI();
        }
        
        // ============ È£üÊùêÈÄâÊã© ============
        function toggleIngredient(id) {
            const index = gameState.selectedIngredients.indexOf(id);
            if (index > -1) {
                gameState.selectedIngredients.splice(index, 1);
            } else if (gameState.selectedIngredients.length < 3) {
                gameState.selectedIngredients.push(id);
            }
            
            soundManager.playClick();
            renderIngredients();
            updateSelectedCount();
        }
        
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = 
                `(Â∑≤ÈÄâ: ${gameState.selectedIngredients.length}/3)`;
        }
        
        // ============ ÁÉπÈ•™Á≥ªÁªü ============
        function startCookingAtStation(stationIndex) {
            if (gameState.selectedCustomer === null) {
                showToast('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰ΩçÈ°æÂÆ¢ÔºÅ', 'error');
                return;
            }
            
            if (gameState.selectedIngredients.length !== 3) {
                showToast('ËØ∑ÈÄâÊã©3ÁßçÈ£üÊùêÔºÅ', 'error');
                return;
            }
            
            const customer = gameState.customers[gameState.selectedCustomer];
            
            // Ê£ÄÊü•È£üÊùêÊòØÂê¶Ê≠£Á°Æ
            const correctIngredients = customer.dishIngredients.every(ing => 
                gameState.selectedIngredients.includes(ing)
            );
            
            if (!correctIngredients) {
                showToast('È£üÊùêÊê≠ÈÖç‰∏çÊ≠£Á°ÆÔºÅ', 'error');
                return;
            }
            
            // ÂºÄÂßãÁÉπÈ•™ - ÂêØÂä®Canvas‰∫§‰∫í
            startCanvasCooking(stationIndex, customer);
        }
        
        // ============ CanvasÁÉπÈ•™Á≥ªÁªü ============
        const cookingCanvas = {
            canvas: null,
            ctx: null,
            currentStep: 0,
            steps: [],
            score: 0,
            totalScore: 0,
            isActive: false,
            customer: null,
            customerIndex: null,
            stationIndex: null,
            
            // ÂàáËèúÊ∏∏ÊàèÁä∂ÊÄÅ
            cutting: {
                items: [],
                cuts: 0,
                requiredCuts: 5,
                knifeY: 0,
                isSlicing: false,
                lastX: 0
            },
            
            // ÁÇíËèúÊ∏∏ÊàèÁä∂ÊÄÅ
            stirFry: {
                ingredients: [],
                heat: 50,
                targetHeat: { min: 40, max: 70 },
                stirCount: 0,
                requiredStirs: 10,
                wokAngle: 0,
                flames: [],
                isDragging: false,
                lastPos: { x: 0, y: 0 }
            },
            
            // Ê≤πÁÇ∏Ê∏∏ÊàèÁä∂ÊÄÅ
            frying: {
                items: [],
                oilTemp: 0,
                targetTemp: 180,
                cookProgress: 0,
                bubbles: [],
                finished: false,
                failed: false,
                burnProgress: 0
            },
            
            // Ë∞ÉÂë≥Ê∏∏ÊàèÁä∂ÊÄÅ
            seasoning: {
                target: [],
                added: [],
                shaking: false,
                shakeCount: 0
            },
            
            // Ëí∏Âà∂Ê∏∏ÊàèÁä∂ÊÄÅ
            steaming: {
                progress: 0,
                steamLevel: 50,
                lidOpen: false,
                steamParticles: [],
                finished: false
            },
            
            // ÁÖÆ/ÁÇñÊ∏∏ÊàèÁä∂ÊÄÅ
            boiling: {
                progress: 0,
                stirCount: 0,
                bubbles: [],
                burnRisk: 0,
                lastStirTime: 0,
                finished: false,
                failed: false
            },
            
            // ÁÖéÂà∂Ê∏∏ÊàèÁä∂ÊÄÅ
            panFry: {
                items: [],
                currentSide: 0,
                sideProgress: [0, 0],
                flipping: false,
                finished: false,
                failed: false,
                burnedSide: -1
            },
            
            // ËÖåÂà∂Ê∏∏ÊàèÁä∂ÊÄÅ
            marinating: {
                progress: 0,
                pressCount: 0,
                requiredPresses: 8,
                isPressing: false,
                finished: false
            },
            
            // ÊëÜÁõòÊ∏∏ÊàèÁä∂ÊÄÅ
            plating: {
                items: [],
                targets: [],
                dragging: null,
                finished: false
            },
            
            // ÁÉßÁÉ§Ê∏∏ÊàèÁä∂ÊÄÅ
            grilling: {
                items: [],
                grillTemp: 0,
                flipCount: 0,
                finished: false
            },
            
            // ÊêÖÊãå/ÊâìËõãÊ∏∏ÊàèÁä∂ÊÄÅ
            mixing: {
                angle: 0,
                rotations: 0,
                requiredRotations: 3,
                lastAngle: 0,
                centerX: 180,
                centerY: 180,
                finished: false
            },
            
            // ÊèâÈù¢Ê∏∏ÊàèÁä∂ÊÄÅ
            kneading: {
                pressCount: 0,
                requiredPresses: 10,
                doughSize: 1,
                isPressing: false,
                finished: false
            }
        };
        
        function initCookingCanvas() {
            cookingCanvas.canvas = document.getElementById('cooking-canvas');
            cookingCanvas.ctx = cookingCanvas.canvas.getContext('2d');
            
            // ‰∫ã‰ª∂ÁõëÂê¨
            cookingCanvas.canvas.addEventListener('mousedown', onCanvasMouseDown);
            cookingCanvas.canvas.addEventListener('mousemove', onCanvasMouseMove);
            cookingCanvas.canvas.addEventListener('mouseup', onCanvasMouseUp);
            cookingCanvas.canvas.addEventListener('mouseleave', onCanvasMouseUp);
            
            // Ëß¶Êë∏ÊîØÊåÅ
            cookingCanvas.canvas.addEventListener('touchstart', onCanvasTouchStart);
            cookingCanvas.canvas.addEventListener('touchmove', onCanvasTouchMove);
            cookingCanvas.canvas.addEventListener('touchend', onCanvasTouchEnd);
            
            // ÁÅ´ÂäõÊªëÂùó
            document.getElementById('heat-slider').addEventListener('input', onHeatChange);
            
            drawIdleState();
        }
        
        function drawIdleState() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = '#444';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üç≥', w/2, h/2 - 20);
            
            ctx.fillStyle = '#666';
            ctx.font = '16px ZCOOL KuaiLe';
            ctx.fillText('Á≠âÂæÖÁÉπÈ•™...', w/2, h/2 + 30);
        }
        
        function startCanvasCooking(stationIndex, customer) {
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊ≠£Âú®ËøõË°åÁöÑÂæÆÊ∏∏Êàè
            if (gameState.isMiniGameActive) {
                showToast('ËØ∑ÂÖàÂÆåÊàêÂΩìÂâçÁöÑËèúÂìÅÔºÅ', 'error');
                return;
            }
            
            const customerIndex = gameState.selectedCustomer;
            
            // ÈîÅÂÆöÂæÆÊ∏∏ÊàèÁä∂ÊÄÅ
            gameState.isMiniGameActive = true;
            
            cookingCanvas.customer = customer;
            cookingCanvas.customerIndex = customerIndex;
            cookingCanvas.stationIndex = stationIndex;
            cookingCanvas.isActive = true;
            cookingCanvas.currentStep = 0;
            cookingCanvas.totalScore = 0;
            cookingCanvas.stepFinishing = false; // ÈáçÁΩÆÊ≠•È™§ÂÆåÊàêÊ†áÂøó
            
            // Ê†πÊçÆËèúÂìÅÂÜ≥ÂÆöÁÉπÈ•™Ê≠•È™§
            cookingCanvas.steps = getCookingSteps(customer.dishId);
            
            // Êõ¥Êñ∞ÁÉπÈ•™Âè∞Áä∂ÊÄÅ
            gameState.cookingDishes[stationIndex] = {
                name: customer.dishName,
                icon: customer.dishIcon,
                progress: 0,
                customer: customer,
                customerIndex: customerIndex
            };
            
            // Ê∏ÖÈô§ÈÄâÊã©
            gameState.selectedCustomer = null;
            gameState.selectedIngredients = [];
            renderIngredients();
            updateSelectedCount();
            renderCookingStations();
            
            // Êõ¥Êñ∞Èù¢Êùø
            updateCookingPanel();
            startCurrentStep();
        }
        
        function getCookingSteps(dishId) {
            // ‰ªéËèúÂìÅÊï∞ÊçÆ‰∏≠Ëé∑ÂèñÁÉπÈ•™Ê≠•È™§
            for (const [cuisineId, cuisine] of Object.entries(cuisines)) {
                if (cuisine.dishes[dishId]) {
                    const dish = cuisine.dishes[dishId];
                    if (dish.cookingSteps && dish.cookingSteps.length > 0) {
                        return [...dish.cookingSteps];
                    }
                }
            }
            
            // Â¶ÇÊûúËèúÂìÅÊ≤°ÊúâÂÆö‰πâÊ≠•È™§Ôºå‰ΩøÁî®ÈªòËÆ§Ê≠•È™§
            return ['cutting', 'stirFry', 'seasoning'];
        }
        
        function updateCookingPanel() {
            const customer = cookingCanvas.customer;
            const steps = cookingCanvas.steps;
            const currentStep = cookingCanvas.currentStep;
            
            // Êõ¥Êñ∞Ê†áÈ¢ò
            document.getElementById('cooking-panel-title').textContent = 
                `üç≥ ${customer ? customer.dishName : 'ÁÉπÈ•™Âè∞'}`;
            
            // Êõ¥Êñ∞Ê≠•È™§‰ø°ÊÅØ
            const stepNames = {
                cutting: 'üî™ ÂàáËèú',
                stirFry: 'ü•ò ÁøªÁÇí',
                frying: 'üçü Ê≤πÁÇ∏',
                seasoning: 'üßÇ Ë∞ÉÂë≥',
                steaming: '‚ô®Ô∏è Ëí∏Âà∂',
                boiling: 'üç≤ ÁÖÆÁÇñ',
                panFry: 'üç≥ ÁÖéÂà∂',
                marinating: 'ü•£ ËÖåÂà∂',
                plating: 'üçΩÔ∏è ÊëÜÁõò',
                grilling: 'üî• ÁÉßÁÉ§',
                mixing: 'ü•Ñ ÊêÖÊãå',
                kneading: 'ü´ì ÊèâÈù¢'
            };
            
            if (cookingCanvas.isActive && steps[currentStep]) {
                // ÊòæÁ§∫ÂΩìÂâçÊ≠•È™§ÂíåÊÄªÊ≠•È™§
                const stepInfo = document.getElementById('cooking-step-info');
                const stepsPreview = steps.map((s, i) => {
                    const stepIcon = stepNames[s].split(' ')[0];
                    if (i < currentStep) return `<span style="color: #4ade80;">‚úì</span>`;
                    if (i === currentStep) return `<span style="color: #ffd700;">${stepIcon}</span>`;
                    return `<span style="color: #666;">${stepIcon}</span>`;
                }).join(' ‚Üí ');
                
                stepInfo.innerHTML = `
                    <div>Ê≠•È™§ ${currentStep + 1}/${steps.length}: ${stepNames[steps[currentStep]]}</div>
                    <div style="font-size: 12px; margin-top: 5px;">${stepsPreview}</div>
                `;
            } else {
                document.getElementById('cooking-step-info').textContent = 'ÈÄâÊã©È°æÂÆ¢ÂºÄÂßãÁÉπÈ•™';
            }
            
            // Êõ¥Êñ∞ÂæÖÂ§ÑÁêÜÈ£üÊùê
            const pendingDiv = document.getElementById('pending-ingredients');
            if (customer) {
                pendingDiv.innerHTML = customer.dishIngredients.map((ing, i) => 
                    `<div class="pending-item ${i <= currentStep ? 'done' : ''} ${i === currentStep ? 'active' : ''}">${ingredients[ing].icon}</div>`
                ).join('');
            } else {
                pendingDiv.innerHTML = '';
            }
        }
        
        function startCurrentStep() {
            const step = cookingCanvas.steps[cookingCanvas.currentStep];
            
            // ÂÅúÊ≠¢‰πãÂâçÁöÑÈü≥ÊïàÂæ™ÁéØ
            soundManager.stopAllLoops();
            
            document.getElementById('cooking-hint').style.display = 'block';
            document.getElementById('cooking-progress-container').style.display = 'none';
            document.getElementById('heat-control').style.display = 'none';
            document.getElementById('cooking-action-btn').style.display = 'none';
            
            switch(step) {
                case 'cutting':
                    startCuttingGame();
                    break;
                case 'stirFry':
                    soundManager.startSizzleLoop();
                    startStirFryGame();
                    break;
                case 'frying':
                    soundManager.startSizzleLoop();
                    startFryingGame();
                    break;
                case 'seasoning':
                    startSeasoningGame();
                    break;
                case 'steaming':
                    soundManager.startSteamLoop();
                    startSteamingGame();
                    break;
                case 'boiling':
                    soundManager.startBoilLoop();
                    startBoilingGame();
                    break;
                case 'panFry':
                    soundManager.startSizzleLoop();
                    startPanFryGame();
                    break;
                case 'marinating':
                    startMarinatingGame();
                    break;
                case 'plating':
                    startPlatingGame();
                    break;
                case 'grilling':
                    soundManager.startGrillLoop();
                    startGrillingGame();
                    break;
                case 'mixing':
                    startMixingGame();
                    break;
                case 'kneading':
                    startKneadingGame();
                    break;
            }
            
            updateCookingPanel();
        }
        
        // ========== ÂàáËèúÊ∏∏Êàè ==========
        function startCuttingGame() {
            const cutting = cookingCanvas.cutting;
            cutting.cuts = 0;
            cutting.requiredCuts = 5;
            cutting.items = [];
            cutting.isSlicing = false;
            cutting.finished = false;
            
            // ÁîüÊàêË¶ÅÂàáÁöÑÈ£üÊùê
            const ingredient = cookingCanvas.customer.dishIngredients[0];
            const icon = ingredients[ingredient]?.icon || 'ü•¨';
            
            for (let i = 0; i < 5; i++) {
                cutting.items.push({
                    x: 60 + i * 60,
                    y: 180,
                    icon: icon,
                    cut: false
                });
            }
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>Â∑¶Âè≥ÊªëÂä®</b>ÂàáËèúÔºÅ<br>‚ÜîÔ∏è ÊääÈº†Ê†áÁßªÂà∞È£üÊùê‰∏äÔºåÂø´ÈÄüÂ∑¶Âè≥ÁßªÂä®Êù•ÂàáÂºÄ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            drawCuttingGame();
        }
        
        function drawCuttingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const cutting = cookingCanvas.cutting;
            
            // ËÉåÊôØ - Á†ßÊùø
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, w, h);
            
            // Êú®Á∫π
            ctx.strokeStyle = '#6B3513';
            ctx.lineWidth = 2;
            for (let i = 0; i < h; i += 20) {
                ctx.beginPath();
                ctx.moveTo(0, i + Math.sin(i * 0.1) * 5);
                ctx.lineTo(w, i + Math.sin(i * 0.1 + 2) * 5);
                ctx.stroke();
            }
            
            // ÂàáÂâ≤Á∫øÊ†áËÆ∞
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.setLineDash([5, 5]);
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(90 + i * 60, 140);
                ctx.lineTo(90 + i * 60, 220);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // È£üÊùê
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            cutting.items.forEach((item, i) => {
                if (!item.cut) {
                    ctx.fillText(item.icon, item.x, item.y);
                } else {
                    // ÂàáÂºÄÁöÑÊïàÊûú
                    ctx.save();
                    ctx.translate(item.x - 15, item.y);
                    ctx.fillText(item.icon, 0, 0);
                    ctx.restore();
                    ctx.save();
                    ctx.translate(item.x + 15, item.y);
                    ctx.fillText(item.icon, 0, 0);
                    ctx.restore();
                }
            });
            
            // ÂàÄ
            ctx.font = '50px Arial';
            ctx.fillText('üî™', w/2, cutting.knifeY || 80);
            
            // ËøõÂ∫¶
            const progress = (cutting.cuts / cutting.requiredCuts) * 100;
            updateProgress(progress);
            
            if (cutting.cuts >= cutting.requiredCuts && !cutting.finished) {
                cutting.finished = true;
                finishCurrentStep(Math.min(100, 70 + cutting.cuts * 6));
            }
        }
        
        // ========== ÁÇíËèúÊ∏∏Êàè ==========
        function startStirFryGame() {
            const stir = cookingCanvas.stirFry;
            stir.heat = 50;
            stir.stirCount = 0;
            stir.requiredStirs = 10;
            stir.wokAngle = 0;
            stir.wokY = 220; // ÈîÖÁöÑY‰ΩçÁΩÆÔºàÂü∫ÂáÜÔºâ
            stir.baseY = 220; // ÂàùÂßã‰ΩçÁΩÆ
            stir.isDragging = false;
            stir.ingredients = [];
            stir.flames = [];
            stir.finished = false;
            stir.lastY = 0; // ‰∏äÊ¨°Y‰ΩçÁΩÆ
            stir.direction = 0; // ÁßªÂä®ÊñπÂêë: 1=Âêë‰∏ä, -1=Âêë‰∏ã, 0=ÈùôÊ≠¢
            stir.peakReached = false; // ÊòØÂê¶Âà∞ËææÈ°∂ÁÇπ
            
            // ÁîüÊàêÈîÖ‰∏≠È£üÊùê
            cookingCanvas.customer.dishIngredients.forEach((ing, i) => {
                stir.ingredients.push({
                    icon: ingredients[ing]?.icon || 'ü•¨',
                    x: -30 + i * 30,
                    y: 20 + Math.random() * 20,
                    vx: 0,
                    vy: 0,
                    airborne: false // ÊòØÂê¶Âú®Á©∫‰∏≠
                });
            });
            
            // ÁîüÊàêÁÅ´ÁÑ∞
            for (let i = 0; i < 8; i++) {
                stir.flames.push({
                    x: 100 + i * 25,
                    y: 320,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>‰∏ä‰∏ãÊãñÂä®</b>ÁÇíÈîÖÊù•ÁøªÁÇíÔºÅ<br>‚¨ÜÔ∏è‚¨áÔ∏è Êåâ‰ΩèÈîÖÂø´ÈÄü‰∏ä‰∏ãÁßªÂä®È¢†Âã∫ | üî• Áî®ÊªëÂùóÊéßÂà∂ÁÅ´Âäõ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            document.getElementById('heat-control').style.display = 'flex';
            
            animateStirFry();
        }
        
        function animateStirFry() {
            if (!cookingCanvas.isActive || cookingCanvas.steps[cookingCanvas.currentStep] !== 'stirFry') return;
            
            drawStirFryGame();
            requestAnimationFrame(animateStirFry);
        }
        
        function drawStirFryGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const stir = cookingCanvas.stirFry;
            
            // ËÉåÊôØ
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁÅ´ÁÑ∞
            const time = Date.now() / 100;
            stir.flames.forEach(flame => {
                const flameHeight = 20 + Math.sin(time + flame.phase) * 10;
                const heatFactor = stir.heat / 100;
                
                ctx.fillStyle = `rgba(255, ${100 + stir.heat}, 0, ${0.5 + heatFactor * 0.5})`;
                ctx.beginPath();
                ctx.ellipse(flame.x, flame.y, 15, flameHeight * heatFactor, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // ÈîÖ - Ê†πÊçÆwokY‰ΩçÁΩÆÁªòÂà∂
            ctx.save();
            ctx.translate(180, stir.wokY);
            ctx.rotate(stir.wokAngle * Math.PI / 180);
            
            // ÈîÖË∫´
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(0, 30, 120, 60, 0, 0, Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.ellipse(0, 30, 100, 45, 0, 0, Math.PI);
            ctx.fill();
            
            // ÈîÖÂÜÖÈ£üÊùê
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            stir.ingredients.forEach(ing => {
                // ÁÆÄÂçïÁâ©ÁêÜ - ÈáçÂäõ
                if (ing.airborne) {
                    ing.vy += 0.8; // ÈáçÂäõ
                    ing.y += ing.vy;
                    ing.x += ing.vx;
                    ing.vx *= 0.98;
                    
                    // ËêΩÂõûÈîÖÂÜÖ
                    if (ing.y > 40) {
                        ing.y = 40;
                        ing.vy = 0;
                        ing.airborne = false;
                    }
                } else {
                    // Âú®ÈîÖÂÜÖÁöÑÊ≠£Â∏∏ÈòªÂ∞º
                    ing.vx *= 0.9;
                    ing.vy *= 0.9;
                    ing.x += ing.vx;
                    ing.y += ing.vy;
                }
                
                // ËæπÁïå
                if (ing.x < -80) ing.x = -80;
                if (ing.x > 80) ing.x = 80;
                if (ing.y < -60) ing.y = -60;
                if (ing.y > 50) ing.y = 50;
                
                ctx.fillText(ing.icon, ing.x, ing.y);
            });
            
            ctx.restore();
            
            // ÈîÖÊüÑ - Ë∑üÈöèÈîÖÁßªÂä®
            ctx.fillStyle = '#654321';
            ctx.fillRect(280, stir.wokY + 10, 60, 15);
            
            // ‰∏ä‰∏ãÁÆ≠Â§¥ÊèêÁ§∫
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillText('‚¨ÜÔ∏è', 50, 150);
            ctx.fillText('‚¨áÔ∏è', 50, 280);
            
            // ÁÅ´ÂäõÊåáÁ§∫
            let heatStatus = '‚ùÑÔ∏è Â§™ÂÜ∑';
            let heatColor = '#3b82f6';
            if (stir.heat >= stir.targetHeat.min && stir.heat <= stir.targetHeat.max) {
                heatStatus = '‚úÖ ÂÆåÁæé';
                heatColor = '#22c55e';
            } else if (stir.heat > stir.targetHeat.max) {
                heatStatus = 'üî• Â§™ÁÉ≠';
                heatColor = '#ef4444';
            }
            
            ctx.fillStyle = heatColor;
            ctx.font = '16px ZCOOL KuaiLe';
            ctx.textAlign = 'center';
            ctx.fillText(heatStatus, 180, 30);
            
            // ÁøªÁÇíÊ¨°Êï∞ÊòæÁ§∫
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(`È¢†Âã∫: ${stir.stirCount}/${stir.requiredStirs}`, 180, 55);
            
            // ËøõÂ∫¶
            const progress = (stir.stirCount / stir.requiredStirs) * 100;
            updateProgress(progress);
            
            // Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàêÔºàÊ∑ªÂä†Èò≤ÈáçÂ§çÊ†áÂøóÔºâ
            if (stir.stirCount >= stir.requiredStirs && !stir.finished) {
                stir.finished = true; // Ê†áËÆ∞‰∏∫Â∑≤ÂÆåÊàê
                const heatBonus = (stir.heat >= stir.targetHeat.min && stir.heat <= stir.targetHeat.max) ? 30 : 0;
                finishCurrentStep(70 + heatBonus);
            }
        }
        
        // ========== Ê≤πÁÇ∏Ê∏∏Êàè ==========
        function startFryingGame() {
            const fry = cookingCanvas.frying;
            fry.oilTemp = 100;
            fry.targetTemp = 180;
            fry.cookProgress = 0;
            fry.items = [];
            fry.bubbles = [];
            fry.finished = false;
            fry.failed = false;
            fry.burnProgress = 0;
            
            // È£üÊùê
            const ingredient = cookingCanvas.customer.dishIngredients[1] || cookingCanvas.customer.dishIngredients[0];
            fry.items.push({
                icon: ingredients[ingredient]?.icon || 'üçó',
                x: 180,
                y: 150,
                cooked: 0
            });
            
            document.getElementById('cooking-hint').innerHTML = 'üí° Áî®ÊªëÂùóË∞ÉÊï¥<b>ÁÅ´Âäõ</b>‰øùÊåÅÊ≤πÊ∏©ÔºÅ<br>üå°Ô∏è ‰øùÊåÅÊ≤πÊ∏©Âú®170-190¬∞CÔºåË∂ÖËøá220¬∞C‰ºöÁÇ∏Á≥äÔºÅ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            document.getElementById('heat-control').style.display = 'flex';
            
            animateFrying();
        }
        
        function animateFrying() {
            if (!cookingCanvas.isActive || cookingCanvas.steps[cookingCanvas.currentStep] !== 'frying') return;
            
            const fry = cookingCanvas.frying;
            const stir = cookingCanvas.stirFry;
            
            // Â¶ÇÊûúÂ∑≤Â§±Ë¥•‰∏çÁªßÁª≠
            if (fry.failed) {
                drawFryingGame();
                return;
            }
            
            // Ê∏©Â∫¶ÂèòÂåñ
            const targetTemp = 100 + stir.heat * 1.2;
            fry.oilTemp += (targetTemp - fry.oilTemp) * 0.05;
            
            // Âú®Ê≠£Á°ÆÊ∏©Â∫¶Êó∂Â¢ûÂä†ËøõÂ∫¶
            if (fry.oilTemp >= 170 && fry.oilTemp <= 190) {
                fry.cookProgress += 0.4;
                fry.burnProgress = Math.max(0, fry.burnProgress - 0.2);
            } else if (fry.oilTemp > 190 && fry.oilTemp <= 220) {
                fry.cookProgress += 0.3;
                fry.burnProgress += 0.3;
            } else if (fry.oilTemp > 220) {
                fry.burnProgress += 0.8;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶ÁÉßÁÑ¶‰∫Ü
            if (fry.burnProgress >= 100) {
                fry.failed = true;
                drawFryingGame();
                showStepFailedUI('ÁÇ∏Á≥ä‰∫ÜÔºÅ', 'Ê≤πÊ∏©Â§™È´òÔºåÈ£üÊùêÂ∑≤ÁªèÁÉßÁÑ¶‰∫ÜÔºÅ');
                return;
            }
            
            // Ê∞îÊ≥°
            if (Math.random() < fry.oilTemp / 200) {
                fry.bubbles.push({
                    x: 100 + Math.random() * 160,
                    y: 250,
                    size: 3 + Math.random() * 5,
                    speed: 1 + Math.random() * 2
                });
            }
            
            drawFryingGame();
            
            // Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàê
            if (fry.cookProgress >= 100 && !fry.finished) {
                fry.finished = true;
                const tempBonus = (fry.oilTemp >= 170 && fry.oilTemp <= 190) ? 30 : 0;
                finishCurrentStep(70 + tempBonus);
            } else if (!fry.finished) {
                requestAnimationFrame(animateFrying);
            }
        }
        
        function drawFryingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const fry = cookingCanvas.frying;
            const stir = cookingCanvas.stirFry;
            
            // ËÉåÊôØ
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁÅ´ÁÑ∞
            const time = Date.now() / 100;
            for (let i = 0; i < 6; i++) {
                const flameHeight = 15 + Math.sin(time + i) * 8;
                ctx.fillStyle = `rgba(255, ${100 + stir.heat}, 0, 0.7)`;
                ctx.beginPath();
                ctx.ellipse(100 + i * 35, 320, 15, flameHeight, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ê≤πÈîÖ
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.roundRect(80, 180, 200, 100, 10);
            ctx.fill();
            
            // Ê≤πÈ¢úËâ≤Ê†πÊçÆÊ∏©Â∫¶ÂíåÁÉßÁÑ¶Á®ãÂ∫¶ÂèòÂåñ
            let oilColor = '#DAA520';
            if (fry.failed) {
                oilColor = '#1a0f0a';
            } else if (fry.oilTemp > 220) {
                oilColor = '#4a3728';
            } else if (fry.oilTemp > 190) {
                oilColor = '#8B4513';
            }
            ctx.fillStyle = oilColor;
            ctx.beginPath();
            ctx.roundRect(90, 190, 180, 80, 5);
            ctx.fill();
            
            // Ê∞îÊ≥°
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            fry.bubbles = fry.bubbles.filter(b => {
                b.y -= b.speed;
                if (b.y < 190) return false;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
                return true;
            });
            
            // ÁÉüÈõæÊïàÊûúÔºàÂ§±Ë¥•Êó∂Ôºâ
            if (fry.failed) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 4; i++) {
                    const smokeY = 150 - i * 20 - Math.sin(time + i) * 5;
                    ctx.globalAlpha = 0.5 - i * 0.1;
                    ctx.fillText('üí®', 150 + i * 20, smokeY);
                }
                ctx.globalAlpha = 1;
            }
            
            // È£üÊùê
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            fry.items.forEach(item => {
                if (fry.failed) {
                    ctx.fillText('üíÄ', item.x, item.y + Math.sin(time) * 3);
                } else {
                    ctx.fillText(item.icon, item.x, item.y + Math.sin(time) * 3);
                }
            });
            
            // Ê∏©Â∫¶ÊòæÁ§∫
            let tempColor = '#3b82f6';
            if (fry.oilTemp >= 170 && fry.oilTemp <= 190) tempColor = '#22c55e';
            else if (fry.oilTemp > 220) tempColor = '#ef4444';
            else if (fry.oilTemp > 190) tempColor = '#fb923c';
            
            ctx.fillStyle = tempColor;
            ctx.font = 'bold 20px ZCOOL KuaiLe';
            ctx.fillText(`üå°Ô∏è ${Math.round(fry.oilTemp)}¬∞C`, 180, 40);
            
            ctx.fillStyle = '#888';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText('ÁõÆÊ†á: 170-190¬∞C | Âç±Èô©: >220¬∞C', 180, 60);
            
            // ÁÉßÁÑ¶È£éÈô©Êù°
            if (fry.burnProgress > 0) {
                ctx.fillStyle = '#333';
                ctx.fillRect(300, 100, 20, 150);
                
                const burnHeight = (fry.burnProgress / 100) * 150;
                ctx.fillStyle = fry.burnProgress > 70 ? '#ef4444' : fry.burnProgress > 40 ? '#fb923c' : '#eab308';
                ctx.fillRect(300, 250 - burnHeight, 20, burnHeight);
                
                ctx.fillStyle = '#888';
                ctx.font = '10px Arial';
                ctx.save();
                ctx.translate(295, 175);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('ÁÉßÁÑ¶', 0, 0);
                ctx.restore();
            }
            
            // ËøõÂ∫¶
            updateProgress(fry.cookProgress);
        }
        
        // ========== Ë∞ÉÂë≥Ê∏∏Êàè ==========
        function startSeasoningGame() {
            const season = cookingCanvas.seasoning;
            const seasoningOptions = ['üßÇ', 'ü´ó', 'üå∂Ô∏è', 'üßÑ', 'üçØ', 'ü´í'];
            
            // ÈöèÊú∫ÁõÆÊ†áË∞ÉÊñôÁªÑÂêà
            season.target = [];
            for (let i = 0; i < 3; i++) {
                season.target.push(seasoningOptions[Math.floor(Math.random() * seasoningOptions.length)]);
            }
            season.added = [];
            season.currentIndex = 0;
            season.finished = false; // Ê∑ªÂä†ÂÆåÊàêÊ†áÂøó
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÁÇπÂáªË∞ÉÊñô</b>ÊåâÈ°∫Â∫èÊ∑ªÂä†ÔºÅ<br>üëÜ ÁúãÈ°∂ÈÉ®ÊòæÁ§∫ÁöÑË∞ÉÊñôÈ°∫Â∫èÔºå‰æùÊ¨°ÁÇπÂáªÁõ∏ÂêåÁöÑË∞ÉÊñô';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            drawSeasoningGame();
        }
        
        function drawSeasoningGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const season = cookingCanvas.seasoning;
            
            // ËÉåÊôØ - Ë∞ÉÂë≥Âè∞
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁõÆÊ†áÂå∫Âüü
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.roundRect(30, 20, 300, 80, 10);
            ctx.fill();
            
            ctx.fillStyle = '#888';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.textAlign = 'center';
            ctx.fillText('ÈúÄË¶ÅÁöÑË∞ÉÊñô:', 180, 45);
            
            // ÁõÆÊ†áË∞ÉÊñô
            ctx.font = '35px Arial';
            season.target.forEach((s, i) => {
                const x = 100 + i * 70;
                ctx.fillStyle = i < season.added.length ? 
                    (season.added[i] === s ? 'rgba(74,222,128,0.3)' : 'rgba(239,68,68,0.3)') : 
                    'rgba(255,255,255,0.1)';
                ctx.beginPath();
                ctx.roundRect(x - 25, 55, 50, 50, 8);
                ctx.fill();
                ctx.fillText(s, x, 95);
            });
            
            // Ë∞ÉÊñôÈÄâÊã©Âå∫
            const seasoningOptions = ['üßÇ', 'ü´ó', 'üå∂Ô∏è', 'üßÑ', 'üçØ', 'ü´í'];
            ctx.font = '40px Arial';
            
            seasoningOptions.forEach((s, i) => {
                const x = 60 + (i % 3) * 100;
                const y = 180 + Math.floor(i / 3) * 100;
                
                // ÊåâÈíÆËÉåÊôØ
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.roundRect(x - 35, y - 35, 70, 70, 10);
                ctx.fill();
                
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillText(s, x, y + 12);
            });
            
            // ËøõÂ∫¶
            const progress = (season.added.length / season.target.length) * 100;
            updateProgress(progress);
        }
        
        function checkSeasoningClick(x, y) {
            const seasoningOptions = ['üßÇ', 'ü´ó', 'üå∂Ô∏è', 'üßÑ', 'üçØ', 'ü´í'];
            const season = cookingCanvas.seasoning;
            
            // Â¶ÇÊûúÂ∑≤ÂÆåÊàêÂàô‰∏çÂ§ÑÁêÜ
            if (season.finished) return;
            
            seasoningOptions.forEach((s, i) => {
                const bx = 60 + (i % 3) * 100;
                const by = 180 + Math.floor(i / 3) * 100;
                
                if (x >= bx - 35 && x <= bx + 35 && y >= by - 35 && y <= by + 35) {
                    season.added.push(s);
                    soundManager.playSeasoning();
                    drawSeasoningGame();
                    
                    if (season.added.length >= season.target.length && !season.finished) {
                        season.finished = true;
                        // ËÆ°ÁÆóÂàÜÊï∞
                        let correct = 0;
                        season.added.forEach((added, i) => {
                            if (added === season.target[i]) correct++;
                        });
                        const score = Math.round((correct / season.target.length) * 100);
                        finishCurrentStep(score);
                    }
                }
            });
        }
        
        // ========== Ëí∏Âà∂Ê∏∏Êàè ==========
        function startSteamingGame() {
            const steam = cookingCanvas.steaming;
            steam.progress = 0;
            steam.steamLevel = 50;
            steam.lidOpen = false;
            steam.steamParticles = [];
            steam.finished = false;
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÁÇπÂáªÈîÖÁõñ</b>ÊéßÂà∂Ëí∏Ê±ΩÔºå‰øùÊåÅËí∏Ê±ΩÂú®ÁªøËâ≤Âå∫ÂüüÔºÅ<br>‚¨ÜÔ∏è Áõñ‰∏äÈîÖÁõñÂ¢ûÂä†Ëí∏Ê±Ω | ‚¨áÔ∏è ÊâìÂºÄÈîÖÁõñÈáäÊîæËí∏Ê±Ω';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            animateSteaming();
        }
        
        function animateSteaming() {
            if (!cookingCanvas.isActive || cookingCanvas.steps[cookingCanvas.currentStep] !== 'steaming') return;
            
            const steam = cookingCanvas.steaming;
            
            // Ëí∏Ê±ΩÂèòÂåñ
            if (steam.lidOpen) {
                steam.steamLevel -= 0.8;
            } else {
                steam.steamLevel += 0.5;
            }
            steam.steamLevel = Math.max(0, Math.min(100, steam.steamLevel));
            
            // Âú®Ê≠£Á°ÆËåÉÂõ¥ÂÜÖÂ¢ûÂä†ËøõÂ∫¶
            if (steam.steamLevel >= 40 && steam.steamLevel <= 70) {
                steam.progress += 0.6;
            } else if (steam.steamLevel > 80) {
                steam.progress += 0.2; // ËøáÁÉ≠ÊïàÊûúÂ∑Æ
            }
            
            // Ëí∏Ê±ΩÁ≤íÂ≠ê
            if (!steam.lidOpen && Math.random() < 0.3) {
                steam.steamParticles.push({
                    x: 140 + Math.random() * 80,
                    y: 150,
                    size: 5 + Math.random() * 10,
                    speed: 1 + Math.random() * 2,
                    opacity: 0.8
                });
            }
            
            drawSteamingGame();
            
            if (steam.progress >= 100 && !steam.finished) {
                steam.finished = true;
                const bonus = (steam.steamLevel >= 40 && steam.steamLevel <= 70) ? 30 : 0;
                finishCurrentStep(70 + bonus);
            } else if (!steam.finished) {
                requestAnimationFrame(animateSteaming);
            }
        }
        
        function drawSteamingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const steam = cookingCanvas.steaming;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // Ëí∏Á¨ºÂ∫ïÈÉ®
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(180, 280, 100, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ëí∏Á¨ºË∫´‰Ωì
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(80, 180, 200, 100);
            
            // Á´πÁºñÁ∫πÁêÜ
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo(80, 180 + i * 10);
                ctx.lineTo(280, 180 + i * 10);
                ctx.stroke();
            }
            
            // È£üÊùê
            const ingredient = cookingCanvas.customer.dishIngredients[0];
            const icon = ingredients[ingredient]?.icon || 'ü•ü';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(icon, 180, 240);
            
            // Ëí∏Ê±ΩÁ≤íÂ≠ê
            steam.steamParticles = steam.steamParticles.filter(p => {
                p.y -= p.speed;
                p.opacity -= 0.02;
                if (p.opacity <= 0) return false;
                
                ctx.fillStyle = `rgba(255,255,255,${p.opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                return true;
            });
            
            // ÈîÖÁõñ
            ctx.fillStyle = steam.lidOpen ? '#666' : '#888';
            ctx.beginPath();
            ctx.ellipse(180, steam.lidOpen ? 120 : 160, 110, 25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ÈîÖÁõñÊääÊâã
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(180, steam.lidOpen ? 105 : 145, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Ëí∏Ê±ΩÊåáÁ§∫Âô®
            ctx.fillStyle = '#333';
            ctx.fillRect(30, 50, 30, 200);
            
            // ÁêÜÊÉ≥Âå∫Âüü
            ctx.fillStyle = 'rgba(74,222,128,0.3)';
            ctx.fillRect(30, 50 + 200 * 0.3, 30, 200 * 0.3);
            
            // ÂΩìÂâçËí∏Ê±Ω
            const steamHeight = (steam.steamLevel / 100) * 200;
            ctx.fillStyle = steam.steamLevel > 80 ? '#ef4444' : 
                           (steam.steamLevel >= 40 && steam.steamLevel <= 70) ? '#22c55e' : '#3b82f6';
            ctx.fillRect(30, 250 - steamHeight, 30, steamHeight);
            
            // Áä∂ÊÄÅÊèêÁ§∫
            let status = '‚ùÑÔ∏è Ëí∏Ê±Ω‰∏çË∂≥';
            if (steam.steamLevel >= 40 && steam.steamLevel <= 70) status = '‚úÖ ÂÆåÁæéËí∏Ê±Ω';
            else if (steam.steamLevel > 70) status = 'üî• Ëí∏Ê±ΩËøáÂ§ö';
            
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(status, 180, 30);
            ctx.fillText(steam.lidOpen ? 'üîì ÈîÖÁõñÊâìÂºÄ' : 'üîí ÈîÖÁõñÂÖ≥Èó≠', 180, 320);
            
            updateProgress(steam.progress);
        }
        
        function handleSteamingInteraction(x, y, type) {
            if (type === 'down') {
                // ÁÇπÂáªÈîÖÁõñÂå∫ÂüüÂàáÊç¢Áä∂ÊÄÅ
                if (y < 200) {
                    cookingCanvas.steaming.lidOpen = !cookingCanvas.steaming.lidOpen;
                }
            }
        }
        
        // ========== ÁÖÆ/ÁÇñÊ∏∏Êàè ==========
        function startBoilingGame() {
            const boil = cookingCanvas.boiling;
            boil.progress = 0;
            boil.stirCount = 0;
            boil.bubbles = [];
            boil.burnRisk = 0;
            boil.lastStirTime = Date.now();
            boil.finished = false;
            boil.failed = false;
            boil.isDragging = false;
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÁîªÂúàÊêÖÊãå</b>Èò≤Ê≠¢Á≥äÈîÖÔºÅ<br>üîÑ ÊåÅÁª≠Âú®ÈîÖ‰∏≠ÁîªÂúàÊêÖÊãåÔºåÁ≥äÈîÖÈ£éÈô©ËææÂà∞100%‰ºöÂ§±Ë¥•ÔºÅ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            animateBoiling();
        }
        
        function animateBoiling() {
            if (!cookingCanvas.isActive || cookingCanvas.steps[cookingCanvas.currentStep] !== 'boiling') return;
            
            const boil = cookingCanvas.boiling;
            
            // Â¶ÇÊûúÂ∑≤Â§±Ë¥•‰∏çÁªßÁª≠
            if (boil.failed) {
                drawBoilingGame();
                return;
            }
            
            // Ê£ÄÊµãÊòØÂê¶Â§™‰πÖÊ≤°ÊêÖÊãå
            const timeSinceStir = Date.now() - boil.lastStirTime;
            if (timeSinceStir > 2000) {
                boil.burnRisk += 0.5;
            } else {
                boil.burnRisk = Math.max(0, boil.burnRisk - 0.3);
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Á≥äÈîÖ‰∫Ü
            if (boil.burnRisk >= 100) {
                boil.failed = true;
                drawBoilingGame();
                showStepFailedUI('Á≥äÈîÖ‰∫ÜÔºÅ', 'Ê≤°ÊúâÂèäÊó∂ÊêÖÊãåÔºåÈîÖÂ∫ïÂ∑≤ÁªèÁÉßÁÑ¶‰∫ÜÔºÅ');
                return;
            }
            
            // ËøõÂ∫¶
            if (boil.burnRisk < 50) {
                boil.progress += 0.4;
            }
            
            // Ê∞îÊ≥°
            if (Math.random() < 0.4) {
                boil.bubbles.push({
                    x: 100 + Math.random() * 160,
                    y: 250,
                    size: 3 + Math.random() * 8,
                    speed: 1 + Math.random() * 2
                });
            }
            
            drawBoilingGame();
            
            if (boil.progress >= 100 && !boil.finished) {
                boil.finished = true;
                const bonus = boil.burnRisk < 30 ? 30 : 0;
                finishCurrentStep(70 + bonus);
            } else if (!boil.finished) {
                requestAnimationFrame(animateBoiling);
            }
        }
        
        function drawBoilingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const boil = cookingCanvas.boiling;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁÅ´ÁÑ∞
            const time = Date.now() / 100;
            for (let i = 0; i < 6; i++) {
                const flameHeight = 15 + Math.sin(time + i) * 8;
                ctx.fillStyle = 'rgba(255, 150, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(100 + i * 35, 320, 15, flameHeight, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ÈîÖ
            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.ellipse(180, 200, 120, 80, 0, 0, Math.PI);
            ctx.fill();
            
            // Ê±§È¢úËâ≤Ê†πÊçÆÁ≥äÈîÖÁ®ãÂ∫¶ÂèòÂåñ
            let soupColor = '#D2691E';
            if (boil.failed) {
                soupColor = '#1a0f0a';
            } else if (boil.burnRisk > 70) {
                soupColor = '#4a3728';
            } else if (boil.burnRisk > 50) {
                soupColor = '#8B4513';
            }
            ctx.fillStyle = soupColor;
            ctx.beginPath();
            ctx.ellipse(180, 200, 100, 60, 0, 0, Math.PI);
            ctx.fill();
            
            // ÁÉüÈõæÊïàÊûúÔºàÂ§±Ë¥•Êó∂Ôºâ
            if (boil.failed) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 3; i++) {
                    const smokeY = 140 - i * 20 - Math.sin(time + i) * 5;
                    ctx.globalAlpha = 0.5 - i * 0.15;
                    ctx.fillText('üí®', 160 + i * 20, smokeY);
                }
                ctx.globalAlpha = 1;
            }
            
            // Ê∞îÊ≥°
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            boil.bubbles = boil.bubbles.filter(b => {
                b.y -= b.speed;
                if (b.y < 160) return false;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
                return true;
            });
            
            // È£üÊùê
            const ingredient = cookingCanvas.customer.dishIngredients[0];
            const icon = boil.failed ? 'üíÄ' : (ingredients[ingredient]?.icon || 'ü•¨');
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(icon, 150, 200);
            ctx.fillText(icon, 210, 190);
            
            // Âã∫Â≠ê
            ctx.font = '40px Arial';
            ctx.fillText('ü•Ñ', 180, 180);
            
            // Á≥äÈîÖÈ£éÈô©
            ctx.fillStyle = '#333';
            ctx.fillRect(30, 50, 30, 200);
            
            const riskHeight = (boil.burnRisk / 100) * 200;
            ctx.fillStyle = boil.burnRisk > 50 ? '#ef4444' : boil.burnRisk > 30 ? '#eab308' : '#22c55e';
            ctx.fillRect(30, 250 - riskHeight, 30, riskHeight);
            
            ctx.fillStyle = '#888';
            ctx.font = '10px Arial';
            ctx.save();
            ctx.translate(20, 150);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Á≥äÈîÖÈ£éÈô©', 0, 0);
            ctx.restore();
            
            // Áä∂ÊÄÅ
            let status = '‚úÖ ÁÅ´ÂÄôÊ≠£Â•Ω';
            if (boil.burnRisk > 50) status = 'üî• Âø´Á≥äÈîÖ‰∫ÜÔºÅ';
            else if (boil.burnRisk > 30) status = '‚ö†Ô∏è ÈúÄË¶ÅÊêÖÊãå';
            
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.textAlign = 'center';
            ctx.fillText(status, 180, 30);
            
            updateProgress(boil.progress);
        }
        
        function handleBoilingInteraction(x, y, type) {
            const boil = cookingCanvas.boiling;
            
            if (type === 'down') {
                boil.isDragging = true;
                boil.lastPos = { x, y };
            } else if (type === 'move' && boil.isDragging) {
                const dx = x - boil.lastPos.x;
                const dy = y - boil.lastPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 15) {
                    boil.stirCount++;
                    boil.lastStirTime = Date.now();
                    boil.lastPos = { x, y };
                }
            } else if (type === 'up') {
                boil.isDragging = false;
            }
        }
        
        // ========== ÁÖéÂà∂Ê∏∏Êàè ==========
        function startPanFryGame() {
            const pan = cookingCanvas.panFry;
            pan.currentSide = 0;
            pan.sideProgress = [0, 0];
            pan.flipping = false;
            pan.finished = false;
            pan.failed = false;
            pan.burnedSide = -1;
            
            const ingredient = cookingCanvas.customer.dishIngredients[0];
            pan.icon = ingredients[ingredient]?.icon || 'ü•©';
            
            document.getElementById('cooking-hint').innerHTML = 'üí° Á≠âÈ£üÊùê<b>ÂèòÈáëÈªÑ</b>Âêé<b>ÁÇπÂáªÁøªÈù¢</b>ÔºÅ<br>‚è∞ ÊØèÈù¢ÁÖéËá≥60-80%ÊúÄ‰Ω≥ÔºåË∂ÖËøá100%‰ºöÁÖéÁ≥äÔºÅ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            animatePanFry();
        }
        
        function animatePanFry() {
            if (!cookingCanvas.isActive || cookingCanvas.steps[cookingCanvas.currentStep] !== 'panFry') return;
            
            const pan = cookingCanvas.panFry;
            
            // Â¶ÇÊûúÂ∑≤Â§±Ë¥•Ôºå‰∏çÂÜçÊõ¥Êñ∞ËøõÂ∫¶
            if (pan.failed) {
                drawPanFryGame();
                return;
            }
            
            // ÂΩìÂâçÈù¢ÈÄêÊ∏êÂèòÁÜü (ÈÄüÂ∫¶‰ªé0.5Èôç‰ΩéÂà∞0.25ÔºåÂ¢ûÂä†Êõ¥Â§öÂèçÂ∫îÊó∂Èó¥)
            if (!pan.flipping) {
                pan.sideProgress[pan.currentSide] += 0.25;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶ÁÖéÁ≥ä‰∫ÜÔºàË∂ÖËøá100%Ôºâ
            if (pan.sideProgress[pan.currentSide] >= 100) {
                pan.failed = true;
                pan.burnedSide = pan.currentSide;
                drawPanFryGame();
                showStepFailedUI('ÁÖéÁ≥ä‰∫ÜÔºÅ', `${pan.currentSide === 0 ? 'Ê≠£Èù¢' : 'ÂèçÈù¢'}ÁÖéÂæóÂ§™‰πÖ‰∫ÜÔºåÂ∑≤ÁªèÁÉßÁÑ¶‰∫ÜÔºÅ`);
                return;
            }
            
            drawPanFryGame();
            
            // ‰∏§Èù¢ÈÉΩÁÖéÂ•Ω
            if (pan.sideProgress[0] >= 60 && pan.sideProgress[1] >= 60 && !pan.finished) {
                pan.finished = true;
                // ËÆ°ÁÆóÂàÜÊï∞Ôºö60-80%ÊúÄ‰Ω≥
                const score1 = pan.sideProgress[0] >= 60 && pan.sideProgress[0] <= 80 ? 50 : 
                              pan.sideProgress[0] > 80 ? Math.max(20, 50 - (pan.sideProgress[0] - 80)) : 30;
                const score2 = pan.sideProgress[1] >= 60 && pan.sideProgress[1] <= 80 ? 50 : 
                              pan.sideProgress[1] > 80 ? Math.max(20, 50 - (pan.sideProgress[1] - 80)) : 30;
                finishCurrentStep(score1 + score2);
            } else if (!pan.finished) {
                requestAnimationFrame(animatePanFry);
            }
        }
        
        function drawPanFryGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const pan = cookingCanvas.panFry;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁÅ´ÁÑ∞
            const time = Date.now() / 100;
            for (let i = 0; i < 5; i++) {
                const flameHeight = 12 + Math.sin(time + i) * 6;
                ctx.fillStyle = 'rgba(255, 130, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(110 + i * 35, 310, 12, flameHeight, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Âπ≥Â∫ïÈîÖ
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(180, 230, 110, 50, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.ellipse(180, 230, 90, 35, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ÈîÖÊüÑ
            ctx.fillStyle = '#654321';
            ctx.fillRect(270, 220, 70, 20);
            
            // È£üÊùêÈ¢úËâ≤Ê†πÊçÆÁÜüÂ∫¶ÂèòÂåñ
            const progress = pan.sideProgress[pan.currentSide];
            let foodColor;
            if (pan.failed) {
                foodColor = '#1a0f0a'; // ÁÉßÁÑ¶ÈªëËâ≤
            } else if (progress < 30) {
                foodColor = '#FFB6C1'; // Áîü
            } else if (progress < 60) {
                foodColor = '#DEB887'; // ÂçäÁÜü
            } else if (progress < 80) {
                foodColor = '#D2691E'; // ÂÆåÁæé
            } else if (progress < 100) {
                foodColor = '#4a3728'; // ÊúâÁÇπÁÑ¶
            } else {
                foodColor = '#1a0f0a'; // ÁÉßÁÑ¶
            }
            
            // È£üÊùê
            ctx.fillStyle = foodColor;
            ctx.beginPath();
            ctx.ellipse(180, 220, 50, 25, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Â¶ÇÊûúÁÖéÁ≥ä‰∫ÜÊòæÁ§∫ÁÉüÈõæÊïàÊûú
            if (pan.failed) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 3; i++) {
                    const smokeY = 180 - i * 20 - Math.sin(time + i) * 5;
                    ctx.globalAlpha = 0.5 - i * 0.15;
                    ctx.fillText('üí®', 160 + i * 20, smokeY);
                }
                ctx.globalAlpha = 1;
            }
            
            ctx.font = '35px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(pan.failed ? 'üíÄ' : pan.icon, 180, 230);
            
            // ÁøªÈù¢ÊèêÁ§∫
            if (!pan.failed && progress >= 60 && progress < 80 && pan.currentSide === 0) {
                ctx.fillStyle = '#22c55e';
                ctx.font = '16px ZCOOL KuaiLe';
                ctx.fillText('‚ú® ÁÇπÂáªÁøªÈù¢ÔºÅ', 180, 150);
            }
            
            // Âç±Èô©Ë≠¶Âëä
            if (!pan.failed && progress >= 85 && progress < 100) {
                ctx.fillStyle = '#ef4444';
                ctx.font = '16px ZCOOL KuaiLe';
                ctx.fillText('‚ö†Ô∏è Âø´Ë¶ÅÁ≥ä‰∫ÜÔºÅ', 180, 150);
            }
            
            // ‰∏§Èù¢ËøõÂ∫¶
            ctx.fillStyle = '#fff';
            ctx.font = '12px ZCOOL KuaiLe';
            const side0Color = pan.sideProgress[0] >= 100 ? '#ef4444' : pan.sideProgress[0] >= 85 ? '#fb923c' : '#fff';
            const side1Color = pan.sideProgress[1] >= 100 ? '#ef4444' : pan.sideProgress[1] >= 85 ? '#fb923c' : '#fff';
            ctx.fillStyle = side0Color;
            ctx.fillText(`Ê≠£Èù¢: ${Math.round(pan.sideProgress[0])}%`, 80, 50);
            ctx.fillStyle = side1Color;
            ctx.fillText(`ÂèçÈù¢: ${Math.round(pan.sideProgress[1])}%`, 280, 50);
            
            // ÂΩìÂâçÈù¢ÊåáÁ§∫
            ctx.fillStyle = '#ffd700';
            ctx.fillText(pan.currentSide === 0 ? '‚ñº ÁÖéËøôÈù¢' : '', 80, 70);
            ctx.fillText(pan.currentSide === 1 ? '‚ñº ÁÖéËøôÈù¢' : '', 280, 70);
            
            // Áä∂ÊÄÅ
            let status = 'ü•© ÁîüÁöÑ';
            if (pan.failed) status = 'üî• ÁÖéÁ≥ä‰∫ÜÔºÅ';
            else if (progress >= 85) status = '‚ö†Ô∏è Âø´Ë¶ÅÁ≥ä‰∫ÜÔºÅ';
            else if (progress >= 80) status = 'üò± ÊúâÁÇπÁÑ¶‰∫ÜÔºÅ';
            else if (progress >= 60) status = '‚úÖ ÂèØ‰ª•ÁøªÈù¢‰∫Ü';
            else if (progress >= 30) status = '‚è≥ ÁªßÁª≠ÁÖé...';
            
            ctx.fillStyle = pan.failed ? '#ef4444' : '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(status, 180, 30);
            
            const totalProgress = (pan.sideProgress[0] + pan.sideProgress[1]) / 2;
            updateProgress(Math.min(100, totalProgress * 100 / 70));
        }
        
        function handlePanFryInteraction(x, y, type) {
            const pan = cookingCanvas.panFry;
            
            if (type === 'down' && !pan.flipping && pan.currentSide === 0) {
                // ÁøªÈù¢
                pan.flipping = true;
                pan.currentSide = 1;
                showToast('ÁøªÈù¢ÔºÅ', 'success');
                setTimeout(() => { pan.flipping = false; }, 300);
            }
        }
        
        // ========== ËÖåÂà∂Ê∏∏Êàè ==========
        function startMarinatingGame() {
            const mar = cookingCanvas.marinating;
            mar.progress = 0;
            mar.pressCount = 0;
            mar.requiredPresses = 8;
            mar.isPressing = false;
            mar.finished = false;
            mar.pressPoints = [];
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÂèçÂ§çÊåâÂéã</b>È£üÊùêËÆ©ËÖåÊñôÊ∏óÂÖ•ÔºÅ<br>üëá Âú®È£üÊùê‰∏äÁÇπÂáªÂπ∂Êåâ‰ΩèÔºåÈáçÂ§ç8Ê¨°';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            drawMarinatingGame();
        }
        
        function drawMarinatingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const mar = cookingCanvas.marinating;
            
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, w, h);
            
            // ËÖåÂà∂ÁõÜ
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.ellipse(180, 220, 130, 60, 0, 0, Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.ellipse(180, 220, 110, 45, 0, 0, Math.PI);
            ctx.fill();
            
            // ËÖåÊñô
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(180, 220, 100, 35, 0, 0, Math.PI);
            ctx.fill();
            
            // È£üÊùê
            const ingredient = cookingCanvas.customer.dishIngredients[0];
            const icon = ingredients[ingredient]?.icon || 'ü•©';
            
            const scale = mar.isPressing ? 0.8 : 1;
            ctx.font = `${50 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(icon, 180, 210);
            
            // ÊåâÂéãÊïàÊûú
            mar.pressPoints = mar.pressPoints.filter(p => {
                p.radius += 2;
                p.opacity -= 0.05;
                if (p.opacity <= 0) return false;
                
                ctx.strokeStyle = `rgba(139, 69, 19, ${p.opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.stroke();
                return true;
            });
            
            // ËøõÂ∫¶ÊòæÁ§∫
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(`ÊåâÂéãÊ¨°Êï∞: ${mar.pressCount}/${mar.requiredPresses}`, 180, 30);
            
            // ÊâãÊåáÊèêÁ§∫
            if (!mar.isPressing) {
                ctx.font = '30px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText('üëá', 180, 280);
            }
            
            updateProgress((mar.pressCount / mar.requiredPresses) * 100);
        }
        
        function handleMarinatingInteraction(x, y, type) {
            const mar = cookingCanvas.marinating;
            if (mar.finished) return;
            
            if (type === 'down') {
                mar.isPressing = true;
                mar.pressPoints.push({ x, y, radius: 10, opacity: 1 });
                drawMarinatingGame();
            } else if (type === 'up' && mar.isPressing) {
                mar.isPressing = false;
                mar.pressCount++;
                drawMarinatingGame();
                
                if (mar.pressCount >= mar.requiredPresses && !mar.finished) {
                    mar.finished = true;
                    finishCurrentStep(85 + Math.floor(Math.random() * 15));
                }
            }
        }
        
        // ========== ÊëÜÁõòÊ∏∏Êàè ==========
        function startPlatingGame() {
            const plate = cookingCanvas.plating;
            plate.items = [];
            plate.targets = [];
            plate.dragging = null;
            plate.finished = false;
            
            // ÁîüÊàêÈ£üÊùêÂíåÁõÆÊ†á‰ΩçÁΩÆ
            const icons = cookingCanvas.customer.dishIngredients.map(ing => ingredients[ing]?.icon || 'ü•¨');
            const positions = [
                { x: 50, y: 280 },
                { x: 120, y: 280 },
                { x: 190, y: 280 }
            ];
            const targetPositions = [
                { x: 130, y: 150 },
                { x: 180, y: 130 },
                { x: 230, y: 150 }
            ];
            
            icons.forEach((icon, i) => {
                plate.items.push({
                    icon,
                    x: positions[i % 3].x,
                    y: positions[i % 3].y,
                    placed: false
                });
                plate.targets.push({
                    x: targetPositions[i % 3].x,
                    y: targetPositions[i % 3].y
                });
            });
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÊãñÂä®È£üÊùê</b>Âà∞ÁõòÂ≠ê‰∏äÁöÑÁõÆÊ†á‰ΩçÁΩÆÔºÅ<br>üéØ ÊîæÂà∞ÂúÜÂúàÂÜÖÂç≥ÂèØ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            drawPlatingGame();
        }
        
        function drawPlatingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const plate = cookingCanvas.plating;
            
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁõòÂ≠ê
            ctx.fillStyle = '#f5f5f5';
            ctx.beginPath();
            ctx.ellipse(180, 150, 120, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.ellipse(180, 150, 100, 65, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ÁõÆÊ†á‰ΩçÁΩÆ
            plate.targets.forEach((target, i) => {
                ctx.strokeStyle = plate.items[i].placed ? '#22c55e' : 'rgba(255,215,0,0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(target.x, target.y, 25, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            });
            
            // È£üÊùê
            ctx.font = '35px Arial';
            ctx.textAlign = 'center';
            plate.items.forEach((item, i) => {
                ctx.fillText(item.icon, item.x, item.y);
            });
            
            // Áä∂ÊÄÅ
            const placedCount = plate.items.filter(i => i.placed).length;
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(`Â∑≤ÊëÜÊîæ: ${placedCount}/${plate.items.length}`, 180, 30);
            
            updateProgress((placedCount / plate.items.length) * 100);
        }
        
        function handlePlatingInteraction(x, y, type) {
            const plate = cookingCanvas.plating;
            if (plate.finished) return;
            
            if (type === 'down') {
                // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫ÜÈ£üÊùê
                plate.items.forEach((item, i) => {
                    if (!item.placed && Math.abs(x - item.x) < 30 && Math.abs(y - item.y) < 30) {
                        plate.dragging = i;
                    }
                });
            } else if (type === 'move' && plate.dragging !== null) {
                plate.items[plate.dragging].x = x;
                plate.items[plate.dragging].y = y;
                drawPlatingGame();
            } else if (type === 'up' && plate.dragging !== null) {
                const item = plate.items[plate.dragging];
                const target = plate.targets[plate.dragging];
                
                // Ê£ÄÊü•ÊòØÂê¶ÊîæÂà∞ÁõÆÊ†á‰ΩçÁΩÆ
                const dist = Math.sqrt((item.x - target.x) ** 2 + (item.y - target.y) ** 2);
                if (dist < 30) {
                    item.x = target.x;
                    item.y = target.y;
                    item.placed = true;
                    soundManager.playPlate();
                    showToast('ÊîæÂ•Ω‰∫ÜÔºÅ', 'success');
                }
                
                plate.dragging = null;
                drawPlatingGame();
                
                // Ê£ÄÊü•ÊòØÂê¶ÂÖ®ÈÉ®ÂÆåÊàê
                if (plate.items.every(i => i.placed) && !plate.finished) {
                    plate.finished = true;
                    finishCurrentStep(90 + Math.floor(Math.random() * 10));
                }
            }
        }
        
        // ========== ÁÉßÁÉ§Ê∏∏Êàè ==========
        function startGrillingGame() {
            const grill = cookingCanvas.grilling;
            grill.items = [];
            grill.grillTemp = 50;
            grill.flipCount = 0;
            grill.finished = false;
            grill.progress = [0, 0];
            grill.currentSide = 0;
            
            document.getElementById('cooking-hint').innerHTML = 'üí° Áî®ÊªëÂùóÊéßÂà∂<b>ÁÅ´Âäõ</b>ÔºåÁ≠âÂèòËâ≤Âêé<b>ÁÇπÂáªÁøªËΩ¨</b>ÔºÅ<br>üî• ‰øùÊåÅ‰∏≠È´òÁÅ´ (60-80%) ÁÉ§Âà∂ÊïàÊûúÊúÄ‰Ω≥';
            document.getElementById('cooking-progress-container').style.display = 'block';
            document.getElementById('heat-control').style.display = 'flex';
            
            animateGrilling();
        }
        
        function animateGrilling() {
            if (!cookingCanvas.isActive || cookingCanvas.steps[cookingCanvas.currentStep] !== 'grilling') return;
            
            const grill = cookingCanvas.grilling;
            const heat = cookingCanvas.stirFry.heat;
            
            // Ê†πÊçÆÁÅ´ÂäõÂ¢ûÂä†ÁÉ§Âà∂ËøõÂ∫¶
            const cookSpeed = heat / 100 * 0.8;
            grill.progress[grill.currentSide] += cookSpeed;
            
            drawGrillingGame();
            
            // ‰∏§Èù¢ÈÉΩÁÉ§Â•Ω
            if (grill.progress[0] >= 50 && grill.progress[1] >= 50 && !grill.finished) {
                grill.finished = true;
                const avgProgress = (grill.progress[0] + grill.progress[1]) / 2;
                const bonus = (avgProgress >= 50 && avgProgress <= 80) ? 30 : 0;
                finishCurrentStep(70 + bonus);
            } else if (!grill.finished) {
                requestAnimationFrame(animateGrilling);
            }
        }
        
        function drawGrillingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const grill = cookingCanvas.grilling;
            const heat = cookingCanvas.stirFry.heat;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // ÁÇ≠ÁÅ´
            const time = Date.now() / 100;
            for (let i = 0; i < 8; i++) {
                const glowSize = 15 + Math.sin(time + i) * 5;
                ctx.fillStyle = `rgba(255, ${50 + heat}, 0, ${0.3 + heat/200})`;
                ctx.beginPath();
                ctx.arc(70 + i * 35, 300, glowSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ÁÉ§Êû∂
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 8;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(60, 180 + i * 20);
                ctx.lineTo(300, 180 + i * 20);
                ctx.stroke();
            }
            
            // È£üÊùê
            const ingredient = cookingCanvas.customer.dishIngredients[0];
            const icon = ingredients[ingredient]?.icon || 'üçñ';
            
            const progress = grill.progress[grill.currentSide];
            let color;
            if (progress < 30) color = '#FFB6C1';
            else if (progress < 60) color = '#D2691E';
            else if (progress < 80) color = '#8B4513';
            else color = '#2d1f1f';
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(180, 230, 60, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(icon, 180, 240);
            
            // ÁÉ§Áóï
            if (progress > 20) {
                ctx.strokeStyle = '#2d1f1f';
                ctx.lineWidth = 3;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(140 + i * 25, 215);
                    ctx.lineTo(140 + i * 25, 245);
                    ctx.stroke();
                }
            }
            
            // ËøõÂ∫¶ÊòæÁ§∫
            ctx.fillStyle = '#fff';
            ctx.font = '12px ZCOOL KuaiLe';
            ctx.fillText(`Ê≠£Èù¢: ${Math.round(grill.progress[0])}%`, 80, 50);
            ctx.fillText(`ÂèçÈù¢: ${Math.round(grill.progress[1])}%`, 280, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.fillText(grill.currentSide === 0 ? '‚ñº' : '', 80, 70);
            ctx.fillText(grill.currentSide === 1 ? '‚ñº' : '', 280, 70);
            
            // ÁøªÈù¢ÊèêÁ§∫
            if (progress >= 50 && progress < 70 && grill.currentSide === 0) {
                ctx.fillStyle = '#22c55e';
                ctx.font = '14px ZCOOL KuaiLe';
                ctx.fillText('‚ú® ÁÇπÂáªÁøªÈù¢ÔºÅ', 180, 150);
            }
            
            const totalProgress = (grill.progress[0] + grill.progress[1]) / 2;
            updateProgress(Math.min(100, totalProgress * 100 / 60));
        }
        
        function handleGrillingInteraction(x, y, type) {
            const grill = cookingCanvas.grilling;
            
            if (type === 'down' && grill.currentSide === 0 && grill.progress[0] >= 50) {
                grill.currentSide = 1;
                grill.flipCount++;
                soundManager.playFlip();
                showToast('ÁøªÈù¢ÔºÅ', 'success');
            }
        }
        
        // ========== ÊêÖÊãå/ÊâìËõãÊ∏∏Êàè ==========
        function startMixingGame() {
            const mix = cookingCanvas.mixing;
            mix.angle = 0;
            mix.rotations = 0;
            mix.requiredRotations = 3;
            mix.lastAngle = 0;
            mix.centerX = 180;
            mix.centerY = 200;
            mix.finished = false;
            mix.totalAngle = 0;
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÁîªÂúàÊêÖÊãå</b>ÔºÅÂõ¥ÁªïÁ¢óÁöÑ‰∏≠ÂøÉÁîªÂúÜÂúà<br>üîÑ ÂÆåÊàê3ÂúàÊêÖÊãåÂç≥ÂèØ';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            drawMixingGame();
        }
        
        function drawMixingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const mix = cookingCanvas.mixing;
            
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, w, h);
            
            // Á¢ó
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.ellipse(180, 200, 120, 80, 0, 0, Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#eee';
            ctx.beginPath();
            ctx.ellipse(180, 200, 100, 60, 0, 0, Math.PI);
            ctx.fill();
            
            // ÂÜÖÂÆπÁâ©
            const mixColor = mix.rotations >= mix.requiredRotations ? '#FFF8DC' : '#FFFACD';
            ctx.fillStyle = mixColor;
            ctx.beginPath();
            ctx.ellipse(180, 200, 90, 50, 0, 0, Math.PI);
            ctx.fill();
            
            // ÊêÖÊãåÁóïËøπ
            if (mix.rotations > 0) {
                ctx.strokeStyle = 'rgba(255,215,0,0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < mix.rotations; i++) {
                    ctx.beginPath();
                    ctx.arc(180, 200, 40 + i * 15, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // ÊêÖÊãåÂô®
            const spoonX = mix.centerX + Math.cos(mix.angle) * 50;
            const spoonY = mix.centerY + Math.sin(mix.angle) * 30;
            ctx.font = '35px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ü•¢', spoonX, spoonY);
            
            // ÂúÜÂΩ¢ÂºïÂØºÁ∫ø
            ctx.strokeStyle = 'rgba(255,215,0,0.3)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(180, 200, 60, 35, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ËøõÂ∫¶
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(`ÊêÖÊãåÂúàÊï∞: ${mix.rotations}/${mix.requiredRotations}`, 180, 30);
            
            updateProgress((mix.rotations / mix.requiredRotations) * 100);
        }
        
        function handleMixingInteraction(x, y, type) {
            const mix = cookingCanvas.mixing;
            if (mix.finished) return;
            
            if (type === 'move' || type === 'down') {
                // ËÆ°ÁÆóÁõ∏ÂØπ‰∫é‰∏≠ÂøÉÁöÑËßíÂ∫¶
                const dx = x - mix.centerX;
                const dy = (y - mix.centerY) * 2; // Ê§≠ÂúÜ‰øÆÊ≠£
                const newAngle = Math.atan2(dy, dx);
                
                // Ê£ÄÊµãÊòØÂê¶ÂÆåÊàê‰∏ÄÂúà
                if (mix.lastAngle !== 0) {
                    let angleDiff = newAngle - mix.lastAngle;
                    
                    // Â§ÑÁêÜËßíÂ∫¶Ë∑®Ë∂ä
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    mix.totalAngle += angleDiff;
                    
                    // ÊØèËΩ¨‰∏ÄÂúà
                    if (Math.abs(mix.totalAngle) >= Math.PI * 2) {
                        mix.rotations++;
                        mix.totalAngle = 0;
                        soundManager.playMix();
                        showToast(`Á¨¨${mix.rotations}ÂúàÔºÅ`, 'success');
                        
                        if (mix.rotations >= mix.requiredRotations && !mix.finished) {
                            mix.finished = true;
                            finishCurrentStep(90 + Math.floor(Math.random() * 10));
                        }
                    }
                }
                
                mix.lastAngle = newAngle;
                mix.angle = newAngle;
                drawMixingGame();
            }
        }
        
        // ========== ÊèâÈù¢Ê∏∏Êàè ==========
        function startKneadingGame() {
            const knead = cookingCanvas.kneading;
            knead.pressCount = 0;
            knead.requiredPresses = 10;
            knead.doughSize = 1;
            knead.isPressing = false;
            knead.finished = false;
            knead.lastPressTime = 0;
            
            document.getElementById('cooking-hint').innerHTML = 'üí° <b>ÂèçÂ§çÊåâÂéã</b>Èù¢Âõ¢Êù•ÊèâÈù¢ÔºÅ<br>üëá ÁÇπÂáªÈù¢Âõ¢Âπ∂ÊùæÂºÄÔºåÈáçÂ§ç10Ê¨°';
            document.getElementById('cooking-progress-container').style.display = 'block';
            
            drawKneadingGame();
        }
        
        function drawKneadingGame() {
            const ctx = cookingCanvas.ctx;
            const w = cookingCanvas.canvas.width;
            const h = cookingCanvas.canvas.height;
            const knead = cookingCanvas.kneading;
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, w, h);
            
            // Êú®Á∫π
            ctx.strokeStyle = '#6B3513';
            ctx.lineWidth = 2;
            for (let i = 0; i < h; i += 25) {
                ctx.beginPath();
                ctx.moveTo(0, i + Math.sin(i * 0.1) * 3);
                ctx.lineTo(w, i + Math.sin(i * 0.1 + 2) * 3);
                ctx.stroke();
            }
            
            // Èù¢Âõ¢
            const baseSize = 80;
            const currentSize = baseSize * (knead.isPressing ? 0.7 : knead.doughSize);
            const smoothness = Math.min(1, knead.pressCount / knead.requiredPresses);
            
            // Èù¢Âõ¢È¢úËâ≤ÈöèÊèâÈù¢Ê¨°Êï∞Âèò‰∫Æ
            const colorValue = 200 + Math.floor(smoothness * 55);
            ctx.fillStyle = `rgb(${colorValue}, ${colorValue - 20}, ${colorValue - 60})`;
            
            ctx.beginPath();
            ctx.ellipse(180, 200, currentSize, currentSize * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Èù¢Âõ¢Á∫πÁêÜÔºàÈöèÊèâÈù¢Ê¨°Êï∞ÂáèÂ∞ëÔºâ
            if (knead.pressCount < knead.requiredPresses) {
                ctx.strokeStyle = 'rgba(139, 90, 43, 0.3)';
                ctx.lineWidth = 2;
                const lines = Math.max(0, 5 - Math.floor(knead.pressCount / 2));
                for (let i = 0; i < lines; i++) {
                    ctx.beginPath();
                    ctx.moveTo(140 + i * 20, 180);
                    ctx.quadraticCurveTo(180, 200 + Math.random() * 20, 220 - i * 20, 220);
                    ctx.stroke();
                }
            }
            
            // ÊâãÁöÑÊèêÁ§∫
            if (!knead.isPressing) {
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ü§ö', 180, 280);
            } else {
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚úä', 180, 230);
            }
            
            // ËøõÂ∫¶
            ctx.fillStyle = '#fff';
            ctx.font = '14px ZCOOL KuaiLe';
            ctx.fillText(`ÊèâÈù¢Ê¨°Êï∞: ${knead.pressCount}/${knead.requiredPresses}`, 180, 30);
            
            // Èù¢Âõ¢Áä∂ÊÄÅ
            let status = 'ü´ì ÂºÄÂßãÊèâÈù¢';
            if (knead.pressCount >= knead.requiredPresses) status = '‚ú® Èù¢Âõ¢ÂÖâÊªë‰∫ÜÔºÅ';
            else if (knead.pressCount > 6) status = 'üëç Âø´Â•Ω‰∫Ü';
            else if (knead.pressCount > 3) status = 'üí™ ÁªßÁª≠Âä†Ê≤π';
            
            ctx.fillText(status, 180, 320);
            
            updateProgress((knead.pressCount / knead.requiredPresses) * 100);
        }
        
        function handleKneadingInteraction(x, y, type) {
            const knead = cookingCanvas.kneading;
            if (knead.finished) return;
            
            // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáªÂú®Èù¢Âõ¢Âå∫Âüü
            const dist = Math.sqrt((x - 180) ** 2 + ((y - 200) * 1.4) ** 2);
            
            if (type === 'down' && dist < 100) {
                knead.isPressing = true;
                drawKneadingGame();
            } else if (type === 'up' && knead.isPressing) {
                knead.isPressing = false;
                knead.pressCount++;
                knead.doughSize = 1 + (knead.pressCount / knead.requiredPresses) * 0.2;
                soundManager.playKnead();
                drawKneadingGame();
                
                if (knead.pressCount >= knead.requiredPresses && !knead.finished) {
                    knead.finished = true;
                    finishCurrentStep(85 + Math.floor(Math.random() * 15));
                }
            }
        }
        
        // ========== ÈÄöÁî®ÂáΩÊï∞ ==========
        function updateProgress(percent) {
            document.getElementById('cooking-progress-fill').style.width = percent + '%';
            document.getElementById('cooking-progress-text').textContent = Math.round(percent) + '%';
        }
        
        function onHeatChange(e) {
            const heat = parseInt(e.target.value);
            cookingCanvas.stirFry.heat = heat;
            
            let display = '‰∏≠ÁÅ´';
            if (heat < 30) display = 'Â∞èÁÅ´';
            else if (heat < 50) display = '‰∏≠Â∞èÁÅ´';
            else if (heat < 70) display = '‰∏≠ÁÅ´';
            else if (heat < 90) display = 'Â§ßÁÅ´';
            else display = 'ÁåõÁÅ´';
            
            document.getElementById('heat-display').textContent = display;
        }
        
        // ========== Ê≠•È™§Â§±Ë¥•ÂíåÈáçÂÅöÂäüËÉΩ ==========
        function showStepFailedUI(title, message) {
            // ÂàõÂª∫Â§±Ë¥•ÊèêÁ§∫ÂºπÁ™ó
            const overlay = document.createElement('div');
            overlay.id = 'step-failed-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            const panel = document.createElement('div');
            panel.style.cssText = `
                background: linear-gradient(180deg, #3a2a1f 0%, #2d1f1a 100%);
                border: 4px solid #ef4444;
                border-radius: 15px;
                padding: 30px;
                text-align: center;
                max-width: 400px;
                box-shadow: 0 0 30px rgba(239,68,68,0.5);
            `;
            
            panel.innerHTML = `
                <div style="font-size: 60px; margin-bottom: 15px;">üò±</div>
                <div style="font-size: 24px; color: #ef4444; font-family: 'ZCOOL KuaiLe', cursive; margin-bottom: 10px;">
                    ${title}
                </div>
                <div style="font-size: 16px; color: #f5e6d3; margin-bottom: 25px; font-family: 'ZCOOL KuaiLe', cursive;">
                    ${message}
                </div>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="retry-step-btn" style="
                        background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
                        border: 2px solid #ffd700;
                        color: white;
                        font-family: 'ZCOOL KuaiLe', cursive;
                        font-size: 18px;
                        padding: 12px 30px;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">üîÑ ÈáçÊñ∞ÂºÄÂßãËøô‰∏ÄÊ≠•</button>
                    <button id="give-up-btn" style="
                        background: linear-gradient(180deg, #6b7280 0%, #4b5563 100%);
                        border: 2px solid #9ca3af;
                        color: white;
                        font-family: 'ZCOOL KuaiLe', cursive;
                        font-size: 18px;
                        padding: 12px 30px;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">‚ùå ÊîæÂºÉËøôÈÅìËèú</button>
                </div>
            `;
            
            overlay.appendChild(panel);
            document.body.appendChild(overlay);
            
            // ÈáçÊñ∞ÂºÄÂßãÊåâÈíÆ
            document.getElementById('retry-step-btn').onclick = () => {
                overlay.remove();
                retryCurrentStep();
            };
            
            // ÊîæÂºÉÊåâÈíÆ
            document.getElementById('give-up-btn').onclick = () => {
                overlay.remove();
                giveUpCooking();
            };
        }
        
        function retryCurrentStep() {
            // ÈáçÁΩÆÂΩìÂâçÊ≠•È™§ÁöÑÁä∂ÊÄÅ
            const currentStep = cookingCanvas.steps[cookingCanvas.currentStep];
            
            // Ê†πÊçÆÊ≠•È™§Á±ªÂûãÈáçÁΩÆÂØπÂ∫îÁä∂ÊÄÅ
            switch(currentStep) {
                case 'panFry':
                    const pan = cookingCanvas.panFry;
                    pan.currentSide = 0;
                    pan.sideProgress = [0, 0];
                    pan.flipping = false;
                    pan.finished = false;
                    pan.failed = false;
                    pan.burnedSide = -1;
                    break;
                case 'frying':
                    const fry = cookingCanvas.frying;
                    fry.oilTemp = 100;
                    fry.cookProgress = 0;
                    fry.burnProgress = 0;
                    fry.finished = false;
                    fry.failed = false;
                    fry.items.forEach(item => item.cooked = 0);
                    break;
                case 'grilling':
                    const grill = cookingCanvas.grilling;
                    grill.progress = [0, 0];
                    grill.currentSide = 0;
                    grill.finished = false;
                    break;
                case 'boiling':
                    const boil = cookingCanvas.boiling;
                    boil.progress = 0;
                    boil.burnRisk = 0;
                    boil.finished = false;
                    boil.failed = false;
                    boil.lastStirTime = Date.now();
                    break;
                case 'steaming':
                    const steam = cookingCanvas.steaming;
                    steam.progress = 0;
                    steam.steamLevel = 50;
                    steam.finished = false;
                    break;
            }
            
            showToast('üîÑ ÈáçÊñ∞ÂºÄÂßãÔºÅ', 'success');
            startCurrentStep();
        }
        
        function giveUpCooking() {
            cookingCanvas.isActive = false;
            gameState.isMiniGameActive = false;
            soundManager.stopAllLoops();
            soundManager.playFail();
            
            const stationIndex = cookingCanvas.stationIndex;
            const customerIndex = cookingCanvas.customerIndex;
            
            // Âà†Èô§ÁÉπÈ•™Áä∂ÊÄÅ
            delete gameState.cookingDishes[stationIndex];
            
            // È°æÂÆ¢‰∏çÊª°ÊÑèÁ¶ªÂºÄ
            customerLeave(customerIndex, false);
            showToast('üòî È°æÂÆ¢Â§±ÊúõÂú∞Á¶ªÂºÄ‰∫Ü...', 'error');
            
            // Èôç‰ΩéÂ£∞Êúõ
            gameState.reputation = Math.max(0, gameState.reputation - 10);
            gameState.combo = 0;
            
            renderCookingStations();
            updateUI();
            
            // ÈáçÁΩÆÈù¢Êùø
            cookingCanvas.customer = null;
            updateCookingPanel();
            drawIdleState();
            
            document.getElementById('cooking-hint').textContent = 'ÈÄâÊã©‰∏Ä‰ΩçÈ°æÂÆ¢ÔºåÁÑ∂ÂêéÁÇπÂáªÁÉπÈ•™Âè∞ÂºÄÂßãÂà∂‰ΩúÁæéÈ£üÔºÅ';
            document.getElementById('cooking-progress-container').style.display = 'none';
            document.getElementById('heat-control').style.display = 'none';
        }
        
        function finishCurrentStep(score) {
            // Èò≤Ê≠¢ÈáçÂ§çË∞ÉÁî®
            if (cookingCanvas.stepFinishing) return;
            cookingCanvas.stepFinishing = true;
            
            soundManager.stopAllLoops();
            cookingCanvas.totalScore += score;
            cookingCanvas.currentStep++;
            
            if (cookingCanvas.currentStep >= cookingCanvas.steps.length) {
                // ÂÆåÊàêÊâÄÊúâÊ≠•È™§
                finishCanvasCooking();
            } else {
                // ‰∏ã‰∏ÄÊ≠•È™§
                if (score >= 80) {
                    soundManager.playSuccess();
                }
                showToast(`Ê≠•È™§ÂÆåÊàêÔºÅÂæóÂàÜ: ${score}`, score >= 80 ? 'perfect' : 'success');
                setTimeout(() => {
                    cookingCanvas.stepFinishing = false; // ÈáçÁΩÆÊ†áÂøó
                    startCurrentStep();
                }, 500);
            }
        }
        
        function finishCanvasCooking() {
            cookingCanvas.isActive = false;
            soundManager.stopAllLoops();
            
            // Ëß£Èô§ÂæÆÊ∏∏ÊàèÈîÅÂÆö
            gameState.isMiniGameActive = false;
            
            const avgScore = cookingCanvas.totalScore / cookingCanvas.steps.length;
            const customer = cookingCanvas.customer;
            const customerIndex = cookingCanvas.customerIndex;
            const stationIndex = cookingCanvas.stationIndex;
            
            // Âà†Èô§ÁÉπÈ•™Áä∂ÊÄÅ
            delete gameState.cookingDishes[stationIndex];
            
            // ËÆ°ÁÆóÊî∂Áõä
            let rating = '';
            let multiplier = 1;
            
            if (avgScore >= 90) {
                rating = '‚≠ê‚≠ê‚≠ê ÂÆåÁæéÔºÅ';
                multiplier = 1.5;
                gameState.combo++;
                soundManager.playPerfect();
                if (gameState.combo > 1) showCombo(gameState.combo);
            } else if (avgScore >= 70) {
                rating = '‚≠ê‚≠ê ÂæàÂ•ΩÔºÅ';
                multiplier = 1.2;
                gameState.combo++;
                soundManager.playSuccess();
            } else if (avgScore >= 50) {
                rating = '‚≠ê ËøòË°å';
                multiplier = 1.0;
                gameState.combo = 0;
            } else {
                rating = 'üòÖ ÈúÄË¶ÅÁªÉ‰π†';
                multiplier = 0.7;
                gameState.combo = 0;
                soundManager.playFail();
            }
            
            const baseEarning = customer.dishPrice;
            const tipMultiplier = customer.tipMultiplier;
            const comboBonus = 1 + (gameState.combo * 0.1);
            const finalEarning = Math.round(baseEarning * multiplier * tipMultiplier * comboBonus);
            
            // Êõ¥Êñ∞Ê∏∏ÊàèÁä∂ÊÄÅ
            gameState.money += finalEarning;
            gameState.reputation += Math.round(avgScore / 10);
            gameState.totalDishesServed++;
            gameState.dailyGoal.current++;
            
            checkDailyGoal();
            
            if (customer.isCritic && avgScore >= 80) {
                gameState.reputation += 50;
                showAchievement('üìù', 'Â•ΩËØÑÂ¶ÇÊΩÆÔºÅ', 'ÁæéÈ£üËØÑËÆ∫ÂÆ∂Áªô‰∫àÈ´òÂ∫¶ËØÑ‰ª∑ÔºÅÂ£∞Êúõ +50');
            }
            
            customerLeave(customerIndex, true);
            showEarning(finalEarning, rating);
            checkLevelUp();
            
            renderCookingStations();
            updateUI();
            
            // ÈáçÁΩÆÈù¢Êùø
            cookingCanvas.customer = null;
            updateCookingPanel();
            drawIdleState();
            
            document.getElementById('cooking-hint').textContent = 'ÈÄâÊã©‰∏Ä‰ΩçÈ°æÂÆ¢ÔºåÁÑ∂ÂêéÁÇπÂáªÁÉπÈ•™Âè∞ÂºÄÂßãÂà∂‰ΩúÁæéÈ£üÔºÅ';
            document.getElementById('cooking-progress-container').style.display = 'none';
            document.getElementById('heat-control').style.display = 'none';
        }
        
        // ========== ‰∫ã‰ª∂Â§ÑÁêÜ ==========
        function onCanvasMouseDown(e) {
            const rect = cookingCanvas.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            handleCanvasInteraction(x, y, 'down');
        }
        
        function onCanvasMouseMove(e) {
            if (!cookingCanvas.isActive) return;
            
            const rect = cookingCanvas.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            handleCanvasInteraction(x, y, 'move');
        }
        
        function onCanvasMouseUp(e) {
            handleCanvasInteraction(0, 0, 'up');
        }
        
        function onCanvasTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = cookingCanvas.canvas.getBoundingClientRect();
            handleCanvasInteraction(touch.clientX - rect.left, touch.clientY - rect.top, 'down');
        }
        
        function onCanvasTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = cookingCanvas.canvas.getBoundingClientRect();
            handleCanvasInteraction(touch.clientX - rect.left, touch.clientY - rect.top, 'move');
        }
        
        function onCanvasTouchEnd(e) {
            handleCanvasInteraction(0, 0, 'up');
        }
        
        function handleCanvasInteraction(x, y, type) {
            if (!cookingCanvas.isActive) return;
            
            const step = cookingCanvas.steps[cookingCanvas.currentStep];
            
            switch(step) {
                case 'cutting':
                    handleCuttingInteraction(x, y, type);
                    break;
                case 'stirFry':
                    handleStirFryInteraction(x, y, type);
                    break;
                case 'seasoning':
                    if (type === 'down') checkSeasoningClick(x, y);
                    break;
                case 'steaming':
                    handleSteamingInteraction(x, y, type);
                    break;
                case 'boiling':
                    handleBoilingInteraction(x, y, type);
                    break;
                case 'panFry':
                    handlePanFryInteraction(x, y, type);
                    break;
                case 'marinating':
                    handleMarinatingInteraction(x, y, type);
                    break;
                case 'plating':
                    handlePlatingInteraction(x, y, type);
                    break;
                case 'grilling':
                    handleGrillingInteraction(x, y, type);
                    break;
                case 'mixing':
                    handleMixingInteraction(x, y, type);
                    break;
                case 'kneading':
                    handleKneadingInteraction(x, y, type);
                    break;
            }
        }
        
        function handleCuttingInteraction(x, y, type) {
            const cutting = cookingCanvas.cutting;
            
            if (type === 'down') {
                cutting.isSlicing = true;
                cutting.lastX = x;
                cutting.knifeY = y;
            } else if (type === 'move' && cutting.isSlicing) {
                cutting.knifeY = y;
                
                // Ê£ÄÊµãÂàáÂâ≤Âä®‰Ωú
                const dx = Math.abs(x - cutting.lastX);
                if (dx > 30) {
                    // Ê£ÄÊü•ÊòØÂê¶ÂàáÂà∞‰∫ÜÈ£üÊùê
                    cutting.items.forEach((item, i) => {
                        if (!item.cut && Math.abs(x - item.x) < 40 && Math.abs(y - item.y) < 40) {
                            item.cut = true;
                            cutting.cuts++;
                            soundManager.playChop();
                            showToast('ÂàáÔºÅ', 'success');
                        }
                    });
                    cutting.lastX = x;
                }
                
                drawCuttingGame();
            } else if (type === 'up') {
                cutting.isSlicing = false;
            }
        }
        
        function handleStirFryInteraction(x, y, type) {
            const stir = cookingCanvas.stirFry;
            
            if (type === 'down') {
                stir.isDragging = true;
                stir.lastY = y;
                stir.peakReached = false;
            } else if (type === 'move' && stir.isDragging) {
                const dy = y - stir.lastY;
                
                // ÁßªÂä®ÈîÖÁöÑY‰ΩçÁΩÆ
                stir.wokY += dy;
                
                // ÈôêÂà∂ÈîÖÁöÑÁßªÂä®ËåÉÂõ¥ (‰∏äÁßªÊúÄÂ§öÂà∞150Ôºå‰∏ãÁßªÊúÄÂ§öÂà∞260)
                stir.wokY = Math.max(140, Math.min(270, stir.wokY));
                
                // ËΩªÂæÆÂÄæÊñúÊïàÊûú
                stir.wokAngle = dy * 0.3;
                stir.wokAngle = Math.max(-15, Math.min(15, stir.wokAngle));
                
                // Ê£ÄÊµãÈ¢†Âã∫Âä®‰ΩúÔºöÂÖàÂêë‰∏äÂÜçÂêë‰∏ã
                const currentDirection = dy < -3 ? 1 : (dy > 3 ? -1 : stir.direction);
                
                // Âêë‰∏äÁßªÂä®‰∏îÂà∞Ëææ‰∏ÄÂÆöÈ´òÂ∫¶
                if (currentDirection === 1 && stir.wokY < 170) {
                    stir.peakReached = true;
                    // È£üÊùêÈ£ûËµ∑Êù•
                    stir.ingredients.forEach(ing => {
                        if (!ing.airborne) {
                            ing.airborne = true;
                            ing.vy = -8 - Math.random() * 4; // Âêë‰∏äÁöÑÈÄüÂ∫¶
                            ing.vx = (Math.random() - 0.5) * 6;
                        }
                    });
                }
                
                // Âêë‰∏ãÁßªÂä®‰∏î‰πãÂâçÂà∞ËøáÈ°∂ÁÇπ = ÂÆåÊàê‰∏ÄÊ¨°È¢†Âã∫
                if (currentDirection === -1 && stir.peakReached && stir.wokY > 230) {
                    stir.stirCount++;
                    stir.peakReached = false;
                    soundManager.playStirFry();
                    showToast('È¢†Âã∫ÔºÅüç≥', 'success');
                }
                
                stir.direction = currentDirection;
                stir.lastY = y;
            } else if (type === 'up') {
                stir.isDragging = false;
                stir.wokAngle = 0;
                // ÈîÖÂõûÂºπÂà∞ÂàùÂßã‰ΩçÁΩÆ
                stir.wokY = stir.baseY;
            }
        }
        
        function completeCooking(stationIndex) {
            // ‰øùÁïôÂéüÂáΩÊï∞‰ª•ÂÖºÂÆπÂèØËÉΩÁöÑË∞ÉÁî®
            const cooking = gameState.cookingDishes[stationIndex];
            if (!cooking) return;
            delete gameState.cookingDishes[stationIndex];
            renderCookingStations();
        }
        
        function showEarning(amount, rating) {
            showToast(`${rating} +${amount}üí∞`, 'money');
            soundManager.playCoins(Math.min(5, Math.ceil(amount / 20)));
            
            // ÊµÆÂä®ÈáëÂ∏ÅÊïàÊûú
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'floating-coin';
                    coin.textContent = 'üí∞';
                    coin.style.left = (Math.random() * 200 + 500) + 'px';
                    coin.style.top = (Math.random() * 100 + 300) + 'px';
                    document.body.appendChild(coin);
                    setTimeout(() => coin.remove(), 1000);
                }, i * 100);
            }
        }
        
        // ============ ÁâπÊÆä‰∫ã‰ª∂Á≥ªÁªü ============
        function tryTriggerEvent() {
            if (Math.random() > 0.3) return; // 30% Ëß¶ÂèëÁéá
            
            const event = specialEvents[Math.floor(Math.random() * specialEvents.length)];
            showSpecialEvent(event);
        }
        
        function showSpecialEvent(event) {
            soundManager.playEventAlert();
            const panel = document.getElementById('special-event');
            document.getElementById('event-icon').textContent = event.icon;
            document.getElementById('event-title').textContent = event.title;
            document.getElementById('event-desc').textContent = event.desc;
            
            const buttons = document.getElementById('event-buttons');
            buttons.innerHTML = '';
            
            event.options.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.className = 'event-btn ' + (option.negative ? 'negative' : (index === 0 ? 'positive' : 'neutral'));
                btn.textContent = option.text;
                btn.onclick = () => {
                    const result = option.action();
                    panel.classList.remove('active');
                    showToast(result, 'success');
                    updateUI();
                };
                buttons.appendChild(btn);
            });
            
            panel.classList.add('active');
            
            // ÈôêÊó∂‰∫ã‰ª∂
            if (event.timeout) {
                setTimeout(() => {
                    if (panel.classList.contains('active')) {
                        panel.classList.remove('active');
                        const result = event.timeoutAction();
                        showToast(result, 'error');
                        updateUI();
                    }
                }, event.timeout);
            }
        }
        
        // ============ ÊØèÊó•ÁõÆÊ†á ============
        function checkDailyGoal() {
            const goal = gameState.dailyGoal;
            
            document.getElementById('goal-current').textContent = goal.current;
            document.getElementById('goal-fill').style.width = 
                Math.min(100, (goal.current / goal.target) * 100) + '%';
            
            if (goal.current >= goal.target && !goal.completed) {
                goal.completed = true;
                gameState.money += goal.reward;
                soundManager.playGoalComplete();
                showAchievement('üéØ', 'ÁõÆÊ†áËææÊàêÔºÅ', `Ëé∑ÂæóÂ•ñÂä± ${goal.reward}üí∞`);
                
                // ËÆæÁΩÆÊñ∞ÁõÆÊ†á
                setTimeout(() => {
                    goal.target = Math.round(goal.target * 1.2);
                    goal.reward = Math.round(goal.reward * 1.2);
                    goal.current = 0;
                    goal.completed = false;
                    document.getElementById('goal-target').textContent = goal.target;
                    document.getElementById('daily-reward-val').textContent = goal.reward;
                    updateUI();
                }, 2000);
            }
        }
        
        // ============ ÂçáÁ∫ßÁ≥ªÁªü ============
        function openUpgradePanel() {
            soundManager.playClick();
            document.getElementById('overlay').classList.add('active');
            document.getElementById('upgrade-panel').classList.add('active');
            renderUpgrades();
        }
        
        function closeUpgradePanel() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('upgrade-panel').classList.remove('active');
        }
        
        function closeAllPanels() {
            closeUpgradePanel();
            document.getElementById('special-event').classList.remove('active');
        }
        
        function renderUpgrades() {
            const content = document.getElementById('upgrade-content');
            content.innerHTML = '';
            
            // ÊåâÁ±ªÂà´ÂàÜÁªÑ
            const categories = {
                basic: { name: 'Âü∫Á°ÄÂçáÁ∫ß', items: [] }
            };
            
            Object.entries(upgradeData).forEach(([id, upgrade]) => {
                categories[upgrade.category].items.push({ id, ...upgrade });
            });
            
            Object.entries(categories).forEach(([catId, category]) => {
                if (category.items.length === 0) return;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'upgrade-category';
                categoryDiv.innerHTML = `<div class="upgrade-category-title">${category.name}</div>`;
                
                category.items.forEach(upgrade => {
                    const currentLevel = gameState.upgrades[upgrade.id];
                    const isMaxed = currentLevel >= upgrade.maxLevel;
                    const cost = isMaxed ? '-' : upgrade.costs[currentLevel];
                    const canAfford = !isMaxed && gameState.money >= cost;
                    
                    const el = document.createElement('div');
                    el.className = 'upgrade-item';
                    el.innerHTML = `
                        <div class="upgrade-icon">${upgrade.icon}</div>
                        <div class="upgrade-info">
                            <div class="upgrade-name">${upgrade.name}</div>
                            <div class="upgrade-desc">${upgrade.desc}</div>
                            <div class="upgrade-level">Á≠âÁ∫ß: ${currentLevel}/${upgrade.maxLevel}</div>
                        </div>
                        <button class="upgrade-btn" ${!canAfford ? 'disabled' : ''} onclick="buyUpgrade('${upgrade.id}')">
                            ${isMaxed ? 'Â∑≤Êª°Á∫ß' : `üí∞ ${cost}`}
                        </button>
                    `;
                    categoryDiv.appendChild(el);
                });
                
                content.appendChild(categoryDiv);
            });
            
            // ËèúÁ≥ªËß£ÈîÅ‰ø°ÊÅØ
            const cuisineInfo = document.createElement('div');
            cuisineInfo.className = 'upgrade-category';
            cuisineInfo.innerHTML = `
                <div class="upgrade-category-title">üìú ËèúÁ≥ªËß£ÈîÅËøõÂ∫¶</div>
                ${Object.entries(cuisines).map(([id, cuisine]) => {
                    const unlocked = gameState.level >= cuisine.unlockLevel;
                    return `<div style="color: ${unlocked ? 'var(--success-green)' : '#666'}; font-size: 14px; margin: 5px 0; padding: 5px;">
                        ${cuisine.icon} ${cuisine.name} - ${unlocked ? '‚úì Â∑≤Ëß£ÈîÅ' : `Lv.${cuisine.unlockLevel} Ëß£ÈîÅ`}
                    </div>`;
                }).join('')}
            `;
            content.appendChild(cuisineInfo);
        }
        
        function buyUpgrade(upgradeId) {
            const upgrade = upgradeData[upgradeId];
            const currentLevel = gameState.upgrades[upgradeId];
            const cost = upgrade.costs[currentLevel];
            
            if (gameState.money < cost) return;
            
            gameState.money -= cost;
            gameState.upgrades[upgradeId]++;
            
            soundManager.playUpgrade();
            
            if (upgradeId === 'stations') {
                renderCookingStations();
            }
            
            updateUI();
            renderUpgrades();
            showToast(`${upgrade.name} ÂçáÁ∫ßÊàêÂäüÔºÅ`, 'success');
        }
        
        function checkLevelUp() {
            const newLevel = Math.floor(gameState.reputation / 100) + 1;
            
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                soundManager.playLevelUp();
                showAchievement('üéâ', 'ÂçáÁ∫ßÔºÅ', `ÊÅ≠ÂñúËææÂà∞ ${newLevel} Á∫ß`);
                updateUI();
            }
        }
        
        // ============ Ëá™Âä®Ê®°Âºè ============
        function toggleAutoServe() {
            gameState.autoServe = !gameState.autoServe;
            showToast(gameState.autoServe ? 'Ëá™Âä®Ê®°ÂºèÂºÄÂêØ' : 'Ëá™Âä®Ê®°ÂºèÂÖ≥Èó≠', 'success');
            
            if (gameState.autoServe) {
                autoServeLoop();
            }
        }
        
        function autoServeLoop() {
            if (!gameState.autoServe) return;
            
            if (gameState.selectedCustomer === null && gameState.customers.length > 0) {
                selectCustomer(0);
                setTimeout(() => {
                    if (gameState.autoServe && gameState.selectedCustomer !== null) {
                        startCookingAtStation(0);
                    }
                }, 500);
            }
            
            setTimeout(autoServeLoop, 2000);
        }
        
        // ============ UI Êõ¥Êñ∞ ============
        function updateUI() {
            document.getElementById('money-display').textContent = gameState.money;
            document.getElementById('reputation-display').textContent = gameState.reputation;
            document.getElementById('level-display').textContent = gameState.level;
            
            // Êõ¥Êñ∞Ê∏∏ÊàèÊó∂Èó¥ÊòæÁ§∫
            const hour = String(gameState.gameTime.hour).padStart(2, '0');
            const minute = String(gameState.gameTime.minute).padStart(2, '0');
            document.getElementById('game-time-display').textContent = `${hour}:${minute}`;
            
            // Êõ¥Êñ∞Êó∂ÊÆµÂêçÁß∞
            const periodName = getTimePeriodName();
            document.getElementById('time-period-name').textContent = periodName.substring(2);
            document.getElementById('time-period-icon').textContent = periodName.substring(0, 2);
        }
        
        function showToast(message, type) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }
        
        function showCombo(combo) {
            soundManager.playCombo(combo);
            const display = document.getElementById('combo-display');
            display.textContent = `üî• ${combo} ËøûÂáªÔºÅ`;
            display.classList.add('active');
            setTimeout(() => display.classList.remove('active'), 1500);
        }
        
        function showAchievement(icon, title, desc) {
            soundManager.playAchievement();
            const el = document.createElement('div');
            el.className = 'achievement';
            el.innerHTML = `
                <div class="achievement-icon">${icon}</div>
                <div class="achievement-text">
                    <div class="achievement-title">${title}</div>
                    <div>${desc}</div>
                </div>
            `;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 3000);
        }
    </script>
</body>
</html>
